[{"title":"1","url":"/2023/07/12/1/"},{"title":"nullcon HackIM CTF补题","url":"/2023/03/19/ctf/","content":"\n> 之前一直有各种事情没来得及补题，这周日终于闲了下来可以有时间补补题，这次的比赛虽然web就两道题但是很值得补一下的。而本菜鸟也只做出了最简单的第一题。害。现在正是Wolv ctf比赛的时候，看了看web题，嗯，好难。本菜鸟深知实力不够，干脆就趁这个时间把之前的题都补一补。\n\n# 一.cookie伪造\n\n这题应该是非常简单的一道题，下载源码后可以在代码中找到如下语句\n\n```python\n@app.route('/whoami')\ndef whoami():\n    role = request.cookies.get('role','guest')\n    really = request.cookies.get('really', 'no')\n    if role == 'admin':\n        if really == 'yes':\n            resp = 'Admin: ' + os.environ['FLAG']\n        else:\n            resp = 'Guest: Nope'\n    else:\n        resp = 'Guest: Nope'\n    return Response(resp, mimetype='text/plain')\n\nif __name__ == \"__main__\":\n    app.run(host='0.0.0.0', port='8080', debug=False)\n```\n\n可以很清晰的看到上面两个if语句都通过后就可以打印出flag，因此借助burp语句可以很快速的实现。如下图\n\n![](https://s3.bmp.ovh/imgs/2023/03/19/d67e3cc48487afd1.png)\n\n先是用burp抓包，然后构造一下cookie使其可以通过if，点击action将其发送到repeater，然后点击send便可以发送我们构造好了的cookie，之后便可以接收到flag了！如下\n\n![](https://s3.bmp.ovh/imgs/2023/03/19/febe47596ef06c7f.png)\n\n# 二、上传文件\n\n这题的题解主要参照[这个网址](https://www.cnblogs.com/xxpanda/p/17212918.html)\n\n但是很奇怪，我参照这个网址的方法下来出现了没有找到文件的标志\n\n![](https://s3.bmp.ovh/imgs/2023/03/19/5333aefb90522225.png)\n\n于是我又去找了另一个官方的[题解网址](https://ctftime.org/writeup/36347)，根据他的做法下来，也是一样的标志，这样只能说明flag文件已经被官方删除了？？具体原因我也不太清楚。但是方法肯定是这样的，如下\n\n```python\n@app.route('/', methods=['GET'])\ndef index():\n    output = io.StringIO()\n    output.write(\"Send me your zipfile as a POST request and I'll make them accessible to you ;-0.\")\n\n    return Response(output.getvalue(), mimetype='text/plain')\n\n\n@app.route('/', methods=['POST'])\ndef upload():\n    output = io.StringIO()\n    if 'file' not in request.files:\n        output.write(\"No file provided!\\n\")\n        return Response(output.getvalue(), mimetype='text/plain')\n\n    try:\n        file = request.files['file']\n\n        filename = hashlib.md5(secrets.token_hex(8).encode()).hexdigest()\n        dirname = hashlib.md5(filename.encode()).hexdigest()\n\n        dpath = os.path.join(\"/tmp/data\", dirname)\n        fpath = os.path.join(dpath, filename + \".zip\")\n\n        os.mkdir(dpath)\n        file.save(fpath)\n\n\n        with zipfile.ZipFile(fpath) as zipf:\n            files = zipf.infolist()\n            if len(files) > 5:\n                raise Exception(\"Too many files!\")\n\n            total_size = 0\n            for the_file in files:\n                if the_file.file_size > 50:\n                    raise Exception(\"File too big.\")\n\n                total_size += the_file.file_size\n\n            if total_size > 250:\n                raise Exception(\"Files too big in total\")\n\n        check_output(['unzip', '-q', fpath, '-d', dpath])\n\n\n        g = glob.glob(dpath + \"/*\")\n        for f in g:\n            output.write(\"Found a file: \" + f + \"\\n\")\n\n        output.write(\"Find your files at http://...:8088/\" + dirname + \"/\\n\")\n\n\n    except Exception as e:\n        output.write(\"Error :-/\\n\")\n\n    return Response(output.getvalue(), mimetype='text/plain')\n\n\n\nif __name__ == \"__main__\":\n    app.run(host='0.0.0.0', port='8080', debug=True)\n```\n\n先看代码，看见是让我们上传一个zip文件，当时就卡在了上传文件好像没什么用这里了，看了题解是要用软链接，不能直接上传，如下图：\n\n![](https://s3.bmp.ovh/imgs/2023/03/19/a55761c784ae3d80.png)\n\n先输入ln -s 将文件变为软链接格式，然后打包压缩，最后按照下面的代码上传文件\n\n```python\nimport requests\nurl = \"http://52.59.124.14:10015/\"\nfiles = {'file':open('test.zip','rb')}\nres = requests.post(url,files=files)\n\nprint(res.text)\n```\n\n最后回复如下\n\n![](https://s3.bmp.ovh/imgs/2023/03/19/c74d84a09b6ce064.png)\n\n然后在10016端口打开这个网址就会出现下面的网页\n\n![](https://s3.bmp.ovh/imgs/2023/03/19/89c09bd6962d99bd.png)\n\n正常来说应该是点击这个flag@就会出现flag，但是并没有出现，但是方法肯定就是这样的了。\n\n接下来就是有时间补补lactf的题，感觉那个题都还不错，值得补一下，剩下的就是等这个ctf结束看题解了。。。\n","tags":["ctf补题"],"categories":["ctf"]},{"title":"算法-归并排序","url":"/2023/01/16/gui/","content":"\n# <center>一、归并排序</center>\n\n### 1、算法思想\n\n其实这些排序算法都是很基础的东西，要是有考试的话直接sort就够用，但是目的还是学习思想，有些题用这些算法里面的思想可能会有奇效。\n\n###### （一）归并排序思想：\n\n1. 先确定分界点，就是区间中点`mid = (l+r) / 2`\n\n2. 先两侧递归，即先递归左面排序，后递归右面排序\n\n3. 将上面两个排好序的序列合二为一，用到的是双指针算法\n\n###### （二）双指针算法\n\n简单来说就是两个指针分别指向两个有序数列（默认从小到大）的开头，比较两个指针指向的数字，这两个数中较小的数一定是两个序列的最小的数，填入新数组的开头，然后较小的数的指针加一，以此类推\n\n###### （三）稳定性\n\n归并排序是稳定的。稳定的含义简单来说就是在未排序之前两个数的相对位置和排序之后两个数的相对位置一致。就比如排序前a在b左边但是a=b，排序后a仍在b左边，不会在b右边，这就是稳定性。\n\n一般用于对某个对象的属性进行排序的时候，这个对象有多个属性时，比如价格，性价比两项，先对价格进行排序，排好之后再对性价比进行排序，但是要求对相同性价比的商品价格低的优先级仍高于价格高的优先级（即已有a=b，此时ab指代性价比，需要仍保持ab之前的排序不变，即价格的高低顺序一致），而不会反过来，这时候的排序算法就需要有稳定性的排序算法。而不稳定的排序算法（如快排）就会有可能使当a=b的时候ab的相对顺序和之前不一致。\n\n### 2、代码示例（模板来咯）\n\n```cpp\nint tmp[N];\nvoid merge_sort(int q[],int l, int r){\n    if(l >= r) return;\n    int mid = l+r >> 1;\n    merge_sort(q,l,mid);\n    merge_sort(q,mid+1,r);\n    int k = 0,i = l, j = mid+1;\n    while(i <= mid && j <= r)\n        if(q[i] < q[j]) tmp[k++] = q[i++];\n        else tmp[k++] = q[j++];\n    while(i <= mid) tmp[k++] = q[i++]\n    while(j <= r) tmp[k++] = q[j++];\n    for(i = l, j = 0; i <= r; i++,j++) q[i] = tmp[j];\n}\n```\n\n其实这种基础算法归根结底学的是思想，思想应该更加重要。\n\n# <center>二、快速排序</center>\n\n### 1、基本思想\n\n快速排序的基本思想十分简单，如下图，其中**调整位置并且递归**是主体部分，下面我将放出朴素快速排序和最近学到的一种很新的快速排序代码方式，**~~正所谓背模板嘛~~**。仅供参考。\n\n![](https://s3.bmp.ovh/imgs/2023/01/16/b0254238f986d7b8.jpg)\n\n（字丑请见谅）\n\n**注意** ：x位置也可以是随机的，不一定在中点或者左右端点。\n\n### 2、代码如下：\n\n###### （一）朴素快速排序算法：\n\n本来想敲一遍的，但是发现朴素算法不够优雅肯定用不到，所以就讲一下基本思路就好了\n\n1. 建立两个数组a[N]与b[N]；\n\n2. 对q[x]进行扫描，大于等于x的放到a里面，小于x的放到b里面\n\n3. 最后把a里面的数放到q前面，然后紧接着把b里面的数放到q里面完成。\n\n4. 然后分别对左右两边递归。结束\n\n这种算法的时间复杂度不大，仍是O(n)（指一次递归过程中，不是总的时间复杂度），但是用到了额外的空间，空间复杂度较高。下面这种“优雅”的方法可以有效避免这一点。\n\n###### （二）优雅的快排算法\n\n基本思路，用到两个指针i，j；\n\n1. i 指针负责判断指向的数是否小于x，如果符合条件，则自增，如果指向的数 \\leq x，停止移动\n\n2. j 指针负责判断指向的数是否小于x，如果符合条件，则自增，如果指向的数 \\geq x，停止移动\n\n3. 如果i指针和j指针同时停止移动，则交换两指针指向的内容，保证了i指针所指向的数之前全部小于x，j指针指向的数之后均大于x；\n\n4. 当i指针\\geq j指针后，停止循环\n\n5. 然后以l到j，j+1到r为分界分别递归\n\n代码如下\n\n```cpp\nvoid quick_sort(int q[],int l,int r){\n    if(l >= r) return;\n    int i = l-1, j = r+1;\n    int x = q[(l+r)/2];\n    while(i < j){\n       do i++; while(q[i] < x);\n       do j--; while(q[j] > x);\n       if(i < j) swap(q[i],q[j]);\n    }\n    quick_sort(q,l,j);\n    quick_sort(q,j+1,r);\n}\n```\n\n这种方法就有效避免了额外再开辟空间的情况，空间复杂度较好。\n\n# <center>三、二分法</center>\n\n### 1、算法思路\n\n二分查找主要分为两类，一类是整数二分查找，一类是实数二分查找。整数二分查找比较困难，因为边界问题很多，需要考虑的事情很多，下面说一下二分查找的基本思路。\n\n**注：有单调性的一定可以用二分，没有单调性的不一定不能用二分，二分的本质并不是单调性，关系并不是很大**\n\n![](https://s3.bmp.ovh/imgs/2023/01/20/92a8b513b04c4e3b.png)\n\n如上图，整数二分的本质并不在单调性，只不过大部分例子都是单调性有关而已。而实际的本质是把一个区间按**某个性质分为两段**，**（由于是整数二分则上面两段的箭头指向的端点并不重合）**，通过二分就可以分别找出两个箭头所指向的位置。而正由于有两个区间的端点，因此有两个模板分别求这两个箭头指向的位置。简单来说：\n\n- 左侧箭头指向的是符合红色条件的最右侧的位置\n\n- 右侧箭头指向的是符合绿色条件的最左侧的位置\n\n为方便理解，可以以一道经典例题为例：\n\n> 给定一个按照升序排列的长度为 n的整数数组，返回一个元素 k的起始位置和终止位置（位置从 0开始计数）如果数组中不存在该元素，则返回 -1 -1。\n\n即如果序列为1,2,3,3,3,4,5,5，需要返回3的起始位置和终止位置，则用二分较快。其中起始位置的3就代表上图右侧箭头，指向的是符合绿色条件的最左侧的位置，即此处的3把整个区间按性质：是否大于等于3分成两半。左侧均小于三，右侧均大于等于3；终止位置3就代表上图左侧箭头，指向的是符合红色条件的最右侧位置，即此处的3把整个区间按性质：是否小于等于3分成两半。左侧均小于等于三，右侧均大于3\n\n因此，像这种找区间左右端点的题就需要分别使用两种模板，如下：\n\n### 2、代码模板\n\n###### (一)、整数模板\n\n```cpp\n// 模板一\nwhile(l < r){\n    int mid = l + r >> 1;\n    if(check(mid)) r = mid;\n    else l = mid + 1;\n}\n//模板二 if后面跟l就加一\nwhile(l < r){\n    int mid = l+ r + 1 >> 1;   // +1是为了防止死循环\n    if(check(mid)) l = mid;\n    else r = mid - 1;\n}\n```\n\n**注意：L = mid 时，初始化mid的时候需要+1，是为了防止死循环**\n","tags":["算法基础"],"categories":["算法学习"]},{"title":"第0篇文章","url":"/2023/01/14/hello-world/","content":"\n# 欢迎来到我的博客！\n\n俗话说授人以鱼不如授人以渔，本博客主要基于这位大佬的[博客文章](http://blog.haoji.me/build-blog-website-by-hexo-github.html)（网址好像寄了）为教程进行建设的。后续讨论区功能也将加入，希望到时候可以一起来玩♂耍与交流。\n\n（2023.1.16更新）本博客由于之前一段时间比较忙处于完全废弃的状态，如今从新拾起博客，并且换了一个更加美观的主题。今后的博客应该会主要记录一下学习ctf过程中的知识点总结和一些算法的学习总结。（2023.7.12更新）博客再次重整，删去了很多没必要的文章，内容再次精简，希望这是一个新的开始。\n此博客的所有源码均可以在我的[github仓库](https://github.com/thenights1/thenights1.github.io)中找到，各位大佬也可以去github和我一起交流。\n\n如有错误欢迎各位大佬前来指正。\n","tags":["引言"]},{"title":"Markdown基础语法总结","url":"/2022/09/29/Markdown/","content":"\n# 占楼，未来的Markdown的一些语法学习我将会在这里实时更新，如果内容过多我会另设文章\n\n## 就当是一个监督学习的文章占楼！\n\nMarkdown是一种轻量级标记语言，排版语法简洁，让人们更多地关注内容本身而非排版。它使用易读易写的纯文本格式编写文档，可与HTML混编，可导出 HTML、PDF 以及本身的 .md 格式的文件。因简洁、高效、易读、易写，Markdown被大量使用，如Github、Wikipedia、简书等。（搜索引擎得来）   \nMarkdown的语法十分简单，常用的标记符号不超过十个，用于日常写作记录绰绰有余，不到半小时就能完全掌握。\n\n### 1.[标题语法](#1)\n\n### 2.[插入代码语法](#2)\n\n### 3.[跳转目录语法](#3)\n\n### 4.[插入图片语法](#4)\n\n### 5.[删除线问题](#5)\n\n<p id=\"1\"></p>\n\n## 1.Markdown标题语法\n\n要创建标题，在单词或短语前面添加井号 (#):由一到六，#越多标题文字显示越小\n\n如下所示\n\n```\n# head1\n## head2\n### head3\n#### head4\n##### head5\n###### head6\n```\n\n效果如下（注意#后面要加空格）\n\n# head1\n\n## head2\n\n### head3\n\n#### head4\n\n##### head5\n\n###### head6\n\n<p id=\"2\"></p>\n\n## 2.Markdown代码语法\n\n（突然想到也没必要按顺序写笔记，应该是学了什么写什么，嘿嘿，好久没更新了，来浅浅更新一下）\n\nMarkdown支持直接用行缩进四个空格或者一个制表符来创建一个代码块,但是这种要注意代码块要和上一段留出一行来，不然就会无法显示代码块\n\n    int i=;\n    int j=0;\n\n就像上面这种，但是这样我感觉，很不方便，所以我更倾向于下面这种，在代码块的上下分别用用三个~或者三个```将其包起来，这样还能显示代码行数，我更倾向于这种\n\n```\n~~~\nint i=0;\nint j=0;\n~~~\n```\n\n<p id=\"3\"></p>\n\n## 3.Markdown跳转目录语法\n\n这个我测试了半天，简单如下\n\n```\n[标题名](#标题链接)\n```\n\n正常来说标题链接就是小标题的名字，但是我发现我用了之后只能在vscode编写的时候可以跳转，而在网页中无效，我也不知道什么原因，搜索之后也不知道，所以我才用了另一种方法，就是在标题的上方加上这句\n\n```\n[相应标题](#锚点)\n\n<p id= \"锚点\"></p>  //这里的锚点最好用数字1234，很好用\n```\n\n这样就可以跳转啦\n\n<p id=\"4\"></p>\n\n## 4.Markdown插入图片语法\n\n图片相关的代码很简单，常用的就两种（准确的说是我常用），第一种就是简单地插入图片或gif，代码如下\n\n```\n![简单描述，不会显示](图片地址 \"图片描述，当鼠标悬停会显示\")\n\n示例代码：\n\n![简单描述，不会显示](https://upload-bbs.mihoyo.com/format,gif \"图片描述，当鼠标悬停会显示\")\n```\n\n示例如下\n![图片](https://upload-bbs.mihoyo.com/upload/2022/10/04/286746010/cfec48f4dc28a69315f9986dae9d5561_7495227528267660980.gif?x-oss-process=image/auto-orient,0/interlace,1/format,gif \"可爱的小东西\" )\n\n而如果想插入链接，就是点击图片跳转，需要再用一个方括号将原有Markdown图片语法括起来，然后在旁边加上需要链接的网址，如下代码\n\n```\n[![简单描述，不会显示](图片地址 \"图片描述，当鼠标悬停会显示\")](网址)\n```\n\n如下图\n\n[![图片](https://upload-bbs.mihoyo.com/upload/2022/09/27/33087162/56c1464ae633055b7bb74bb3f924328a_3330391065587151535.png# \"好美\")](https://www.bh3.com/)\n\n但是这样图片就太大了，经过一顿百度，发现这东西还和具体的Markdown编辑器有关，不同的编辑器有不同的方式，但是我用的这种好像都不太可以，所以只能回归HTML了，HTML这样表示，可以调整大小，如下：\n\n```\n<img src=\"https://upload-bbs.mihoyo.com/upload/2022/09/27/33087162/56c1464ae633055b7bb74bb3f924328a_3330391065587151535.png\"  width=\"50%\" height=\"50%\" >   //也就是\n<img src=\"图片地址\" width=\" %\" hegiht=\" %\">\n```\n\n[<img src=\"https://upload-bbs.mihoyo.com/upload/2022/09/27/33087162/56c1464ae633055b7bb74bb3f924328a_3330391065587151535.png\" alt=\"好美\" width=\"50%\" height=\"50%\" >](https://www.bh3.com/)\n\n<p id=\"5\"></p>\n\n## 5.删除线问题\n\n今天在写总结的时候发现，删除线并不只是两个~就行，一个也行！？\n代码如下\n\n```\n~我是删除的~\n~ 我是删除的 ~\n~~我是删除的~~\n~~ 我是删除的 ~~\n~ ~ 我是删除的 ~ ~\n```\n\n而效果如下，立竿见影\n\n~我是删除的~\n~ 我是删除的 ~\n~~我是删除的~~\n~~ 我是删除的 ~~\n~ ~ 我是删除的 ~ ~\n\n总结：一个~也能用，但是**必须要贴合文字**，一旦有空格就无法显示删除线，两个 ~也是这样（看我这里打了个空格，不打的话就会和前面那个 ~遥相呼应，就会显示删除线，血泪的教训）","tags":["Markdown"]}]