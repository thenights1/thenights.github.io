[{"title":"nullcon HackIM CTF补题","url":"/2023/03/19/1223/","content":"\n> 之前一直有各种事情没来得及补题，这周日终于闲了下来可以有时间补补题，这次的比赛虽然web就两道题但是很值得补一下的。而本菜鸟也只做出了最简单的第一题。害。现在正是Wolv ctf比赛的时候，看了看web题，嗯，好难。本菜鸟深知实力不够，干脆就趁这个时间把之前的题都补一补。\n\n# 一.cookie伪造\n\n这题应该是非常简单的一道题，下载源码后可以在代码中找到如下语句\n\n```python\n@app.route('/whoami')\ndef whoami():\n    role = request.cookies.get('role','guest')\n    really = request.cookies.get('really', 'no')\n    if role == 'admin':\n        if really == 'yes':\n            resp = 'Admin: ' + os.environ['FLAG']\n        else:\n            resp = 'Guest: Nope'\n    else:\n        resp = 'Guest: Nope'\n    return Response(resp, mimetype='text/plain')\n\nif __name__ == \"__main__\":\n    app.run(host='0.0.0.0', port='8080', debug=False)\n```\n\n可以很清晰的看到上面两个if语句都通过后就可以打印出flag，因此借助burp语句可以很快速的实现。如下图\n\n![](https://s3.bmp.ovh/imgs/2023/03/19/d67e3cc48487afd1.png)\n\n先是用burp抓包，然后构造一下cookie使其可以通过if，点击action将其发送到repeater，然后点击send便可以发送我们构造好了的cookie，之后便可以接收到flag了！如下\n\n![](https://s3.bmp.ovh/imgs/2023/03/19/febe47596ef06c7f.png)\n\n# 二、上传文件\n\n这题的题解主要参照[这个网址](https://www.cnblogs.com/xxpanda/p/17212918.html)\n\n但是很奇怪，我参照这个网址的方法下来出现了没有找到文件的标志\n\n![](https://s3.bmp.ovh/imgs/2023/03/19/5333aefb90522225.png)\n\n于是我又去找了另一个官方的[题解网址](https://ctftime.org/writeup/36347)，根据他的做法下来，也是一样的标志，这样只能说明flag文件已经被官方删除了？？具体原因我也不太清楚。但是方法肯定是这样的，如下\n\n```python\n@app.route('/', methods=['GET'])\ndef index():\n    output = io.StringIO()\n    output.write(\"Send me your zipfile as a POST request and I'll make them accessible to you ;-0.\")\n\n    return Response(output.getvalue(), mimetype='text/plain')\n\n\n@app.route('/', methods=['POST'])\ndef upload():\n    output = io.StringIO()\n    if 'file' not in request.files:\n        output.write(\"No file provided!\\n\")\n        return Response(output.getvalue(), mimetype='text/plain')\n\n    try:\n        file = request.files['file']\n\n        filename = hashlib.md5(secrets.token_hex(8).encode()).hexdigest()\n        dirname = hashlib.md5(filename.encode()).hexdigest()\n\n        dpath = os.path.join(\"/tmp/data\", dirname)\n        fpath = os.path.join(dpath, filename + \".zip\")\n\n        os.mkdir(dpath)\n        file.save(fpath)\n\n\n        with zipfile.ZipFile(fpath) as zipf:\n            files = zipf.infolist()\n            if len(files) > 5:\n                raise Exception(\"Too many files!\")\n\n            total_size = 0\n            for the_file in files:\n                if the_file.file_size > 50:\n                    raise Exception(\"File too big.\")\n\n                total_size += the_file.file_size\n\n            if total_size > 250:\n                raise Exception(\"Files too big in total\")\n\n        check_output(['unzip', '-q', fpath, '-d', dpath])\n\n\n        g = glob.glob(dpath + \"/*\")\n        for f in g:\n            output.write(\"Found a file: \" + f + \"\\n\")\n\n        output.write(\"Find your files at http://...:8088/\" + dirname + \"/\\n\")\n\n\n    except Exception as e:\n        output.write(\"Error :-/\\n\")\n\n    return Response(output.getvalue(), mimetype='text/plain')\n\n\n\nif __name__ == \"__main__\":\n    app.run(host='0.0.0.0', port='8080', debug=True)\n```\n\n先看代码，看见是让我们上传一个zip文件，当时就卡在了上传文件好像没什么用这里了，看了题解是要用软链接，不能直接上传，如下图：\n\n![](https://s3.bmp.ovh/imgs/2023/03/19/a55761c784ae3d80.png)\n\n先输入ln -s 将文件变为软链接格式，然后打包压缩，最后按照下面的代码上传文件\n\n```python\nimport requests\nurl = \"http://52.59.124.14:10015/\"\nfiles = {'file':open('test.zip','rb')}\nres = requests.post(url,files=files)\n\nprint(res.text)\n```\n\n最后回复如下\n\n![](https://s3.bmp.ovh/imgs/2023/03/19/c74d84a09b6ce064.png)\n\n然后在10016端口打开这个网址就会出现下面的网页\n\n![](https://s3.bmp.ovh/imgs/2023/03/19/89c09bd6962d99bd.png)\n\n正常来说应该是点击这个flag@就会出现flag，但是并没有出现，但是方法肯定就是这样的了。\n\n接下来就是有时间补补lactf的题，感觉那个题都还不错，值得补一下，剩下的就是等这个ctf结束看题解了。。。\n","tags":["ctf补题"],"categories":["ctf"]},{"title":"算法-二分查找","url":"/2023/01/19/2fen/","content":"\n# <center>二分查找</center>\n\n#### 一、算法思路\n\n二分查找主要分为两类，一类是整数二分查找，一类是实数二分查找。整数二分查找比较困难，因为边界问题很多，需要考虑的事情很多，下面说一下二分查找的基本思路。\n\n**注：有单调性的一定可以用二分，没有单调性的不一定不能用二分，二分的本质并不是单调性，关系并不是很大**\n\n![](https://s3.bmp.ovh/imgs/2023/01/20/92a8b513b04c4e3b.png)\n\n如上图，整数二分的本质并不在单调性，只不过大部分例子都是单调性有关而已。而实际的本质是把一个区间按**某个性质分为两段**，**（由于是整数二分则上面两段的箭头指向的端点并不重合）**，通过二分就可以分别找出两个箭头所指向的位置。而正由于有两个区间的端点，因此有两个模板分别求这两个箭头指向的位置。简单来说：\n\n- 左侧箭头指向的是符合红色条件的最右侧的位置\n\n- 右侧箭头指向的是符合绿色条件的最左侧的位置\n\n为方便理解，可以以一道经典例题为例：\n\n> 给定一个按照升序排列的长度为 n的整数数组，返回一个元素 k的起始位置和终止位置（位置从 0开始计数）如果数组中不存在该元素，则返回 -1 -1。\n\n即如果序列为1,2,3,3,3,4,5,5，需要返回3的起始位置和终止位置，则用二分较快。其中起始位置的3就代表上图右侧箭头，指向的是符合绿色条件的最左侧的位置，即此处的3把整个区间按性质：是否大于等于3分成两半。左侧均小于三，右侧均大于等于3；终止位置3就代表上图左侧箭头，指向的是符合红色条件的最右侧位置，即此处的3把整个区间按性质：是否小于等于3分成两半。左侧均小于等于三，右侧均大于3\n\n因此，像这种找区间左右端点的题就需要分别使用两种模板，如下：\n\n#### 二、代码模板\n\n###### (一)、整数模板\n\n```cpp\n// 模板一\nwhile(l < r){\n    int mid = l + r >> 1;\n    if(check(mid)) r = mid;\n    else l = mid + 1;\n}\n//模板二 if后面跟l就加一\nwhile(l < r){\n    int mid = l+ r + 1 >> 1;   // +1是为了防止死循环\n    if(check(mid)) l = mid;\n    else r = mid - 1;\n}\n```\n\n**注意：L = mid 时，初始化mid的时候需要+1，是为了防止死循环** \n\n###### (二)、实数模板\n\n```\n\n```\n","tags":["算法基础"],"categories":["算法学习"]},{"title":"算法-归并排序","url":"/2023/01/16/gui/","content":"\n# <center>归并排序</center>\n\n### 一、算法思想\n\n其实这些排序算法都是很基础的东西，要是有考试的话直接sort就够用，但是目的还是学习思想，有些题用这些算法里面的思想可能会有奇效。\n\n###### （一）归并排序思想：\n\n1. 先确定分界点，就是区间中点`mid = (l+r) / 2`\n\n2. 先两侧递归，即先递归左面排序，后递归右面排序\n\n3. 将上面两个排好序的序列合二为一，用到的是双指针算法\n\n###### （二）双指针算法\n\n简单来说就是两个指针分别指向两个有序数列（默认从小到大）的开头，比较两个指针指向的数字，这两个数中较小的数一定是两个序列的最小的数，填入新数组的开头，然后较小的数的指针加一，以此类推\n\n###### （三）稳定性\n\n归并排序是稳定的。稳定的含义简单来说就是在未排序之前两个数的相对位置和排序之后两个数的相对位置一致。就比如排序前a在b左边但是a=b，排序后a仍在b左边，不会在b右边，这就是稳定性。\n\n一般用于对某个对象的属性进行排序的时候，这个对象有多个属性时，比如价格，性价比两项，先对价格进行排序，排好之后再对性价比进行排序，但是要求对相同性价比的商品价格低的优先级仍高于价格高的优先级（即已有a=b，此时ab指代性价比，需要仍保持ab之前的排序不变，即价格的高低顺序一致），而不会反过来，这时候的排序算法就需要有稳定性的排序算法。而不稳定的排序算法（如快排）就会有可能使当a=b的时候ab的相对顺序和之前不一致。\n\n### 二、代码示例（模板来咯）\n\n```cpp\nint tmp[N];\nvoid merge_sort(int q[],int l, int r){\n    if(l >= r) return;\n    int mid = l+r >> 1;\n    merge_sort(q,l,mid);\n    merge_sort(q,mid+1,r);\n    int k = 0,i = l, j = mid+1;\n    while(i <= mid && j <= r)\n        if(q[i] < q[j]) tmp[k++] = q[i++];\n        else tmp[k++] = q[j++];\n    while(i <= mid) tmp[k++] = q[i++]\n    while(j <= r) tmp[k++] = q[j++];\n    for(i = l, j = 0; i <= r; i++,j++) q[i] = tmp[j];\n}\n```\n\n其实这种基础算法归根结底学的是思想，思想应该更加重要。\n","tags":["算法基础"],"categories":["算法学习"]},{"title":"算法-快速排序","url":"/2023/01/16/kuai/","content":"\n# 数据结构算法-快速排序\n\n## 一、基本思想\n\n快速排序的基本思想十分简单，如下图，其中**调整位置并且递归**是主体部分，下面我将放出朴素快速排序和最近学到的一种很新的快速排序代码方式，**~~正所谓背模板嘛~~**。仅供参考。\n\n![](https://s3.bmp.ovh/imgs/2023/01/16/b0254238f986d7b8.jpg)\n\n（字丑请见谅）\n\n**注意** ：x位置也可以是随机的，不一定在中点或者左右端点。\n\n## 二、代码如下：\n\n#### （一）朴素快速排序算法：\n\n本来想敲一遍的，但是发现朴素算法不够优雅肯定用不到，所以就讲一下基本思路就好了\n\n1. 建立两个数组a[N]与b[N]；\n\n2. 对q[x]进行扫描，大于等于x的放到a里面，小于x的放到b里面\n\n3. 最后把a里面的数放到q前面，然后紧接着把b里面的数放到q里面完成。\n\n4. 然后分别对左右两边递归。结束\n\n这种算法的时间复杂度不大，仍是O(n)（指一次递归过程中，不是总的时间复杂度），但是用到了额外的空间，空间复杂度较高。下面这种“优雅”的方法可以有效避免这一点。\n\n#### （二）优雅的快排算法\n\n基本思路，用到两个指针i，j；\n\n1. i 指针负责判断指向的数是否小于x，如果符合条件，则自增，如果指向的数 $\\leq$ x，停止移动\n\n2. j 指针负责判断指向的数是否小于x，如果符合条件，则自增，如果指向的数 $\\geq$ x，停止移动\n\n3. 如果i指针和j指针同时停止移动，则交换两指针指向的内容，保证了i指针所指向的数之前全部小于x，j指针指向的数之后均大于x；\n\n4. 当i指针$\\geq$ j指针后，停止循环\n\n5. 然后以l到j，j+1到r为分界分别递归\n\n代码如下\n\n```cpp\nvoid quick_sort(int q[],int l,int r){\n    if(l >= r) return;\n    int i = l-1, j = r+1;\n    int x = q[(l+r)/2];\n    while(i < j){\n       do i++; while(q[i] < x);\n       do j--; while(q[j] > x);\n       if(i < j) swap(q[i],q[j]);\n    }\n    quick_sort(q,l,j);\n    quick_sort(q,j+1,r);\n}\n```\n\n这种方法就有效避免了额外再开辟空间的情况，空间复杂度较好。\n","tags":["算法基础"],"categories":["算法学习"]},{"title":"第0篇文章","url":"/2023/01/14/hello-world/","content":"\n# 欢迎来到我的博客！\n\n俗话说授人以鱼不如授人以渔，本博客主要基于这位大佬的[博客文章](http://blog.haoji.me/build-blog-website-by-hexo-github.html)（网址好像寄了）为教程进行建设的。后续讨论区功能也将加入，希望到时候可以一起来玩♂耍与交流。\n\n本博客由于之前一段时间比较忙处于完全废弃的状态，如今从新拾起博客，并且换了一个更加美观的主题。今后的博客应该会主要记录一下学习ctf过程中的知识点总结和一些算法的学习总结。\n此博客的所有源码均可以在我的[github仓库](https://github.com/thenights1/thenights1.github.io)中找到，各位大佬也可以去github和我一起交流。\n\n如有错误欢迎各位大佬前来指正。\n","tags":["引言"]},{"title":"数据结构之二叉树","url":"/2022/11/02/11-2/","content":"\n## 树的定义\n\n树是由n个结点组成的有限集合。如果n=0，则为空树。有一个特定的称为**根（root）的结点**只有直接后继，没有直接前驱。\n\n- 结点(node)—包含数据项及指向其它结点的分支。\n- 结点的度(degree)—结点所拥有的子树棵数。       //就是该结点的分支数目\n- 叶(leaf) 结点—即度为0的结点，又称为终端结点。 //就是最底层的结点\n- 分支(branch)结点—除叶结点之外的其它结点，又称为非终端结点。\n- 子女(child)结点—若结点x有子树，则子树的根结点即为结点x的子女。\n- 双亲(parent)结点—若结点x有子女，则它即为子女的双亲。\n- 兄弟(sibling)结点—同一双亲的子女互称为兄弟。\n- 祖先(ancestor)结点—从根结点到该结点所经分支上的所有结点。\n- 子孙(descendant)结点—某一结点的子女，以及这些子女的子女都是该结点的子孙。\n- 结点所处层次(level)—简称结点层次，即从根到该结点所经路径上的分支条数。（树中任一结点的层次为其双亲结点层次加1）\n- 树的深度(depth)—树中结点所处的最大层次。（空树深度为0，只有一个根结点的树深度为1）        //**从上往下变大**\n- 树的高度(height)—自下向上定义高度。叶结点高度为1，非叶结点高度等于其子女结点高度最大值加1。高度与深度计算方向不同，但数值相等。 //**从下往上变大**\n- 树的度(degree)—树中**结点的度的最大值**。\n- 有序树—树中结点的各棵子树T0, T1, …是有次序的，其中T0为根的第1棵子树，T1为根的第2棵子树。\n- 无序树—树中结点的各棵子树之间的次序是不重要的，可以互相交换位置。\n- 森林—为m棵树的集合。若删去一棵非空树的根结点，树就变成森林；若增加一个根结点，让森林中每一棵树的根结点都变成它的子女，则森林就变成一棵树。\n  如图\n  ![树的概览]()\n\n## 二叉树\n\n定义: 一棵二叉树是结点的一个有限集合，该集合或者为空，或者是由一个根结点加上两棵分别称为左子树和右子树的、互不相交的二叉树组成。\n即每个结点最多只有两个子女，也就是不存在度大于2的结点，但是子树有左右之分，次序不能颠倒。\n\n### 二叉树的性质与一些定义\n\n- 性质1: 二叉树的第i层最多有2$^{i-1}$个结点\n- 性质2: 深度为k的二叉树最少有k个结点，最多有2$^k$-1个结点\n- 性质3: 对任何一棵二叉树，如果其叶结点有n0个，度为2的非叶结点有n2个, 则有n0=n2+1\n- 定义1: 满二叉树，显而易见，就是结点达到最大个数，如下图左侧\n- 定义2: 完全二叉树，就是最底层从右到左连续缺几个结点，如下图右侧\n  ![图片]()\n- 性质4: 具有n个结点的完全二叉树的高度为为$\\lceil \\log_2(n+1) \\rceil$(向上取整)\n- 性质5: 直接上图吧，如图\n  ![性质5]()\n\n### 二叉树类定义\n\n```c++\ntemplate <class Type> class BinaryTree;\ntemplate <class Type> class BinTreeNode{\n    friend class BinaryTree<Type>\nprivate:\n    Type data;\n    BinTreeNode <Type> *leftChild;  //左子女\n    BinTreeNode <Type> *rightChild; //右子女\npublic:\n    BinTreeNode():leftChild(NULL),rightChild(NULL){}\n    BinTreeNode (Type item, BinTreeNode <Type> *left = NULL,BinTreeNode <Type> *right = NULL ):\n    data (item), leftChild (left), rightChild (right) { }\n}\n```\n\n## 线索二叉树\n\n创建 插入 删除\n\n结点判断左孩子和右孩子\n\n中序线索二叉树 前驱和后继的判定条件\n转变为前序和后续的判定条件\n\n## 树的存储结构\n","tags":["笔记"],"categories":["数据结构"]},{"title":"一些考试之后的思考","url":"/2022/10/25/cs/","content":"\n# 离散小测出分了，不出所料果然很差\n\n这次小测算是给我一个提醒，我真的学的不怎么样，每天的时间不知道荒废到哪里，感觉那些时间很快便在不经意间从指尖溜走，无法挽回。\n而浪费完时间又自我懊悔，懊悔完不到一会又开始摆烂，这就是每天的精神写照。\n但是，我明白：\n\n**弃我去者昨日之日不可留，乱我心者今日之日多烦忧。**\n\n与其继续自我内耗，不如从现在开始改变自己，我觉得只要我充分利用起来那些被我荒废的时间去做一些有意义的事，这就够了。而我所计划的也不是整天学习学成一个书呆子，而是要充分利用时间去做有意义的事情。说实话我对保研的想法并不是很大，但我对待我应该要学习的知识真的很看重。之前的我都想着没必要天天卷，最后把专业技能搞好也能有出路，但是今天这场考试让我意识到，我甚至连专业技能都搞不好，这才是最能打醒我的一点。\n\n而回想我这前半学期的生活，整天只是为了完成一些作业，对一些知识似懂非懂，大部分时间浪费到了一些一点意义也没有的事情上，这或许根本不是我想要的生活，我其实每天都在浑浑噩噩中度过，今天好好审视一下自己，嗯，果然很差劲。\n\n正如金老师所说，我们在这个时间段应该有了自己的人生目标，想想自己30岁的时候在干什么，嗯，我应该还在敲代码。但我不想当一个代码制造机器。人之所以为人，之所以区别于人工智能，那便是人那所独有的创造力。而我30岁在做的事情，应该是带领团队做项目，是在自主研发，当不上团队领导再不济也要成为一个研发人员，我不想在固定的岗位上天天维护那些前人留下的代码，复制粘贴。而是要不断提升自己的核心竞争力，不会有中年就业危机。嗯。这将是我要为之奋斗的目标，而在当下，那便是打好基础，不然一切都是虚无的。我直至今日才意识到自己前半学期真的什么也没学，一直在吃之前的老本，对ics和数据结构这两门本应有很多很大知识点的基础课上我竟然感觉到了一种什么也没学到的感觉。可怕。\n\n害，用LOL角色的一段话来结束这段文字吧：\n\n## ***说教无益,折断的骨头是更好的课本。***\n\n接下来就是我的一些规划了：\n每天计划（调整生物钟）：\n早上：\n6:50起床\n7:00出宿舍(刷早段)\n7:10出宿舍(不刷早段)\n晚上：\n10:30回宿舍\n11:30睡觉\n\n每日更新：\n\n- ~10/25~\n- 10/26 晚上失败，由于手机没电了只能提前回去\n- 10/27 早上失败，没去上课就起晚了，害\n- ~10/28~\n- ~10/29~\n- 10/30 今天感冒了，就不出去在寝室自习了。。\n- 10/31\n\n## ***“我向神明祈祷，回应我的只有我自己”***\n\n![前进](https://w.wallhaven.cc/full/3l/wallhaven-3loj76.jpg \"前进\")\n","tags":["生活"],"categories":["生活"]},{"title":"忙完最近的ddl，重新拾起博客","url":"/2022/10/21/10-21/","content":"\n## 拖延王最终赶完所有ddl\n\n~离散数学考试~ 寄了\n~bomblab~\n其中bomblab耗时最久，但是写完感觉思路还是不特别明朗，待我日后专门开一篇文章写一下\n其实应该是在昨天肝完一堆ddl，但是昨天刚肝完就没顾得上写博客。那就今天来写一下。\n\n![dd](https://upload-bbs.mihoyo.com/upload/2022/10/06/26200319/e9794f6fd87c10464a94daae36648fb2_2275474599659753777.gif?x-oss-process=image/auto-orient,0/interlace,1/format,gif)\n","tags":["生活"],"categories":["咕咕日记"]},{"title":"ICS-Datalab做题笔记","url":"/2022/10/06/06/","content":"\n# 前言\n\n奶奶滴，回顾整个lab，这真的对我有帮助吗，感觉做完前几个题就已经对二进制数在机器中的表现形式，补码 反码什么的都很熟了，剩下的就全是靠各种“奇淫技巧”解题，但是不得不说有些方法确实值得学习，但是总感觉剩下的大部分都是在为了解题而解题，害，可能也是我太菜了体会不到出题人的良苦用心，今天歇一歇等有时间再进行总结吧（当时做完的感受）\n\n**1.[bitNor](#1)**\n**2.[tmax](#2)**\n**3.[isTmin](#3)**\n**4.[minusOne](#4)**\n**5.[absVal](#5)**\n**6.[leastBitPos](#6)**\n**7.[byteSwap](#7)**\n\n<p id=\"1\"></p>\n\n### 1.bitNor  实现~(x|y) using only ~ and &\n\n这题很简单，代码如下，\n\n```c++\nint bitNor(int x, int y) {\n    return (~x)&(~y);\n}\n```\n\n思路：先理解题意，~ (x|y)理解成对应位置只有是均是0的时候才是1，只要有一个1便是0，所以如果只能用到&和 ~ ，那就是（~ x）&（~ y）\n\n<p id=\"2\"></p>\n\n### 2.tmax 返回最大二进制整数\n\n先贴代码\n\n```c++\nint tmax(void) {\n    return ~(1<<31);\n}\n```\n\n思路：1的32位二进制表示是0000000…00000001，而1<<31,即1左移31位后变成了1000…000000，取反后便成了01111111…111,即为最大二进制整数\n\n<p id=\"3\"></p>\n\n### 3.isTmin 判断是否是最小二进制数\n\n```c++\nint isTmin(int x) {\n  int i=!x;\n    return !(x+x+i);\n}\n```\n\n<p id=\"4\"></p>\n<p id=\"5\"></p>\n<p id=\"6\"></p>\n<p id=\"7\"></p>","tags":["cs-lab"],"categories":["CSAPP"]},{"title":"又是被lab薄纱的一天","url":"/2022/10/05/05/","content":"\n# 继昨天目标只完成一个之后\n\n今天目标定得小一点：\n\n先是完成昨天剩余的目标\n\n- 写完datalab 并更新学习记录\n- 写完数据结构作业 一半 一半就好\n- 写离散数学作业\n\n什么目标？，在lab面前毫无用处\n\n奶奶滴，但这lab做的我收获很大，等我做完了一定要好好总结一下\n\n奇怪现象：\n\n```\nint m=x0<<!n;  \nm=m+!n;  \n```\n\n这样是对的\n\n```\nint m=x0<<!n+!n;\n```\n\n这样就是错的，有意思，先记下来结束再想\n\n对于正数，x/(2^n) = x >> n。接下来推导负数的除法。\n\n奇怪现象加一\n\n```\ny=y+(y<<2);\nx=(x+x+x+x+x)+(y>>3); //这样是对的\n```\n\n```\ny=y+(y<<2);\nx=(x+x+x+x+x)+(y>>3);  //这样就是错的，应该和运算符优先级有关\n```\n\n而当x较大时，x+x>>2与x+x+x+x+x并不相等，也是个问题\n","tags":["学习目标"],"categories":["学习"]},{"title":"10/4 今天要补基物了！","url":"/2022/10/04/03/","content":"\n# 目标贴，预估学习规划\n\n![图片](https://upload-bbs.mihoyo.com/upload/2022/10/04/286746010/cfec48f4dc28a69315f9986dae9d5561_7495227528267660980.gif?x-oss-process=image/auto-orient,0/interlace,1/format,gif \"可爱的小东西\")\n\n- ~~写完基物报告！ 我说的，长痛不如短痛~~\n- 写计基datalab 至少也得写到第14个吧 doge\n- 学汇编语言，做好记录（最后考虑）\n- 写数据结构作业 写完一半就可以 \n\n今晚我会更新完成情况，希望能完成至少三个吧\n\n完成情况：至少三个没完成\n\n<font color=Red>愧疚值：10  （+10）</font>\n（看看能涨到多少）\n\n![tu](https://upload-bbs.mihoyo.com/upload/2022/10/02/286746010/be5ce63df63213864a2eab52cbcab6b4_5830946235707598316.jpg?x-oss-process=image/auto-orient,0/interlace,1/format,jpg \"惨\")\n","tags":["学习目标"],"categories":["学习"]},{"title":"10/2 & 10/3 两天快乐生活结束","url":"/2022/10/02/02/","content":"\n# 这两天算是玩够了，要开始收收心学习了...\n\n基物，你欠我的拿什么还！！！\n\n![这是图片](https://upload-bbs.mihoyo.com/upload/2020/04/05/81753778/645df094f1d85ab9dde19aeea3b86b93_3705418559708854646.gif?x-oss-process=image/auto-orient,0/interlace,1/format,gif \"德丽傻\")\n\n我杀你一千遍也不够！！！！！！\n\n![这是图片](https://upload-bbs.mihoyo.com/upload/2022/07/18/275881676/3ac82a4044d65964e440137d13fc16e4_1543268183327340023.gif?x-oss-process=image/auto-orient,0/interlace,1/format,gif \"退退退\")","tags":["咕咕日记"],"categories":["生活"]},{"title":"10/1","url":"/2022/10/01/10-1/","content":"\n# 今天国庆，当然是要好好玩耍力\n\n去了好多地方，腿都快走断了\n\n![动图](https://upload-bbs.mihoyo.com/upload/2020/05/22/78124755/ba353767c13ff6ccc0a0da270bad8c2d_98868753284970471.gif?x-oss-process=image/auto-orient,0/interlace,1/format,gif \"可爱捏doge\")\n\n外滩人是真的多\n结束！","tags":["咕咕日记"],"categories":["生活"]},{"title":"鸽了鸽了9/30","url":"/2022/09/30/01/","content":"\n# 今天学了好多，但是懒得写了，因为明天国庆力\n\n鸽了鸽了\n\n![动图](https://upload-bbs.mihoyo.com/upload/2022/08/11/270869670/7bf97217bdc20e5aadb031cbd9c9d97c_6636126670882376393.gif?x-oss-process=image/auto-orient,0/interlace,1/format,gif \"起飞\")\n","tags":["咕咕日记"],"categories":["生活"]},{"title":"Markdown基础语法总结","url":"/2022/09/29/Markdown/","content":"\n# 占楼，未来的Markdown的一些语法学习我将会在这里实时更新，如果内容过多我会另设文章\n\n## 就当是一个监督学习的文章占楼！\n\nMarkdown是一种轻量级标记语言，排版语法简洁，让人们更多地关注内容本身而非排版。它使用易读易写的纯文本格式编写文档，可与HTML混编，可导出 HTML、PDF 以及本身的 .md 格式的文件。因简洁、高效、易读、易写，Markdown被大量使用，如Github、Wikipedia、简书等。（搜索引擎得来）   \nMarkdown的语法十分简单，常用的标记符号不超过十个，用于日常写作记录绰绰有余，不到半小时就能完全掌握。\n\n### 1.[标题语法](#1)\n\n### 2.[插入代码语法](#2)\n\n### 3.[跳转目录语法](#3)\n\n### 4.[插入图片语法](#4)\n\n### 5.[删除线问题](#5)\n\n<p id=\"1\"></p>\n\n## 1.Markdown标题语法\n\n要创建标题，在单词或短语前面添加井号 (#):由一到六，#越多标题文字显示越小\n\n如下所示\n\n```\n# head1\n## head2\n### head3\n#### head4\n##### head5\n###### head6\n```\n\n效果如下（注意#后面要加空格）\n\n# head1\n\n## head2\n\n### head3\n\n#### head4\n\n##### head5\n\n###### head6\n\n<p id=\"2\"></p>\n\n## 2.Markdown代码语法\n\n（突然想到也没必要按顺序写笔记，应该是学了什么写什么，嘿嘿，好久没更新了，来浅浅更新一下）\n\nMarkdown支持直接用行缩进四个空格或者一个制表符来创建一个代码块,但是这种要注意代码块要和上一段留出一行来，不然就会无法显示代码块\n\n    int i=;\n    int j=0;\n\n就像上面这种，但是这样我感觉，很不方便，所以我更倾向于下面这种，在代码块的上下分别用用三个~或者三个```将其包起来，这样还能显示代码行数，我更倾向于这种\n\n```\n~~~\nint i=0;\nint j=0;\n~~~\n```\n\n<p id=\"3\"></p>\n\n## 3.Markdown跳转目录语法\n\n这个我测试了半天，简单如下\n\n```\n[标题名](#标题链接)\n```\n\n正常来说标题链接就是小标题的名字，但是我发现我用了之后只能在vscode编写的时候可以跳转，而在网页中无效，我也不知道什么原因，搜索之后也不知道，所以我才用了另一种方法，就是在标题的上方加上这句\n\n```\n[相应标题](#锚点)\n\n<p id= \"锚点\"></p>  //这里的锚点最好用数字1234，很好用\n```\n\n这样就可以跳转啦\n\n<p id=\"4\"></p>\n\n## 4.Markdown插入图片语法\n\n图片相关的代码很简单，常用的就两种（准确的说是我常用），第一种就是简单地插入图片或gif，代码如下\n\n```\n![简单描述，不会显示](图片地址 \"图片描述，当鼠标悬停会显示\")\n\n示例代码：\n\n![简单描述，不会显示](https://upload-bbs.mihoyo.com/format,gif \"图片描述，当鼠标悬停会显示\")\n```\n\n示例如下\n![图片](https://upload-bbs.mihoyo.com/upload/2022/10/04/286746010/cfec48f4dc28a69315f9986dae9d5561_7495227528267660980.gif?x-oss-process=image/auto-orient,0/interlace,1/format,gif \"可爱的小东西\" )\n\n而如果想插入链接，就是点击图片跳转，需要再用一个方括号将原有Markdown图片语法括起来，然后在旁边加上需要链接的网址，如下代码\n\n```\n[![简单描述，不会显示](图片地址 \"图片描述，当鼠标悬停会显示\")](网址)\n```\n\n如下图\n\n[![图片](https://upload-bbs.mihoyo.com/upload/2022/09/27/33087162/56c1464ae633055b7bb74bb3f924328a_3330391065587151535.png# \"好美\")](https://www.bh3.com/)\n\n但是这样图片就太大了，经过一顿百度，发现这东西还和具体的Markdown编辑器有关，不同的编辑器有不同的方式，但是我用的这种好像都不太可以，所以只能回归HTML了，HTML这样表示，可以调整大小，如下：\n\n```\n<img src=\"https://upload-bbs.mihoyo.com/upload/2022/09/27/33087162/56c1464ae633055b7bb74bb3f924328a_3330391065587151535.png\"  width=\"50%\" height=\"50%\" >   //也就是\n<img src=\"图片地址\" width=\" %\" hegiht=\" %\">\n```\n\n[<img src=\"https://upload-bbs.mihoyo.com/upload/2022/09/27/33087162/56c1464ae633055b7bb74bb3f924328a_3330391065587151535.png\" alt=\"好美\" width=\"50%\" height=\"50%\" >](https://www.bh3.com/)\n\n<p id=\"5\"></p>\n\n## 5.删除线问题\n\n今天在写总结的时候发现，删除线并不只是两个~就行，一个也行！？\n代码如下\n\n```\n~我是删除的~\n~ 我是删除的 ~\n~~我是删除的~~\n~~ 我是删除的 ~~\n~ ~ 我是删除的 ~ ~\n```\n\n而效果如下，立竿见影\n\n~我是删除的~\n~ 我是删除的 ~\n~~我是删除的~~\n~~ 我是删除的 ~~\n~ ~ 我是删除的 ~ ~\n\n总结：一个~也能用，但是**必须要贴合文字**，一旦有空格就无法显示删除线，两个 ~也是这样（看我这里打了个空格，不打的话就会和前面那个 ~遥相呼应，就会显示删除线，血泪的教训）","tags":["Markdown"]}]