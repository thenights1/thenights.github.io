[{"title":"攻防世界ctf-web新手题","url":"/2023/07/30/web0/","content":"\n> 最近做逆向题还是有点痛苦，又逐渐回想起当初玩web时候的感觉了。。所以我准备还是逆向和web一起搞，近期先高强度更新一波web再说。\n\n## 一、robots\n\n这题算是让我学到了robots协议是什么，简单理解就是爬虫协议，搜索引擎访问网站的时候第一个访问的协议，就是在里面标明哪些不可以被爬取，而一般都\n\n如下面这题\n","tags":["ctf回顾"],"categories":["ctf"]},{"title":"攻防世界ctf-rev新手题","url":"/2023/07/27/rev2/","content":"\n## 一、insanity\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230727163909.png\" title=\"\" alt=\"\" width=\"354\">\n\n经典拖进ida就有flag（这题目难度有3？），点进strs，得到flag：\n\n9447{This_is_a_flag}  果然是引导题的第一题，好简单\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230727163955.png\" title=\"\" alt=\"\" width=\"337\">\n\n## 二、open-source\n\n这题附件是一个c文件，有点意思，好久没做过类似的题了。\n\n<img title=\"\" src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230727165704.png\" alt=\"\" width=\"540\">\n\n很简单，就需要分析一下代码。\n\n就可以得到first = 0xcafe\n\nsecond % 17 = 8\n\nargv[3] = h4cky0u\n\n然后直接带入最后的式子运行一下就行了，如下\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230727165855.png\" title=\"\" alt=\"\" width=\"509\">\n\nflag就是：c0ffee\n","tags":["ctf回顾"],"categories":["ctf"]},{"title":"攻防世界ctf-1000click/crypt/happyctf","url":"/2023/07/26/rev1/","content":"\n## 一、1000click\n\n这题ida完发现有一千多个函数，本来以为会很难，结果实际上很简单。\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230726143159.png\" title=\"\" alt=\"\" width=\"424\">\n\n首先进入ida，我的思路是，这么多函数显然直接分析代码有点困难了。然后就shift+F12，找字符串，我第一感觉是先找flag，搜索一下，放弃了\n\n<img title=\"\" src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230726143352.png\" alt=\"\" width=\"388\">\n\n然后打开程序\n\n<img title=\"\" src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230726143431.png\" alt=\"\" width=\"401\">\n\n显然点击1000次也是不现实的，没准1000次之后也没有flag，但是发现，check之后会有提示，如下\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230726143649.png\" title=\"\" alt=\"\" width=\"372\">\n\n他有一个error的报错信息，然后我就想着去ida里面搜一下，发现位置，点进去\n\n<img title=\"\" src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230726143729.png\" alt=\"\" width=\"402\">\n\n发现对应函数，进入\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230726143753.png\" title=\"\" alt=\"\" data-align=\"inline\">\n\n然后如下\n\n<img title=\"\" src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230726143825.png\" alt=\"\" width=\"316\">\n\n发现判断函数，然后发现是判断与text比较，点进去text，发现一个flag，然后试了一下，发现对了，就结束了\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230726143916.png)\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230726143941.png\" title=\"\" alt=\"\" width=\"286\">\n\n#### 小结\n\n这题也算是给我一个新的经验了，对待程序类的题目，先根据程序里面的提示，去ida里面搜，直接看最后判断逻辑，没准就做出来了\n\n## 二、crypt\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230726163858.png)\n\n这题，属实是折磨到我了。最开始我看就是对输入字符串进行一顿操作然后判断一下，这我熟悉啊，直接开始用python写脚本，后面发现越写越不对劲。先是拖进ida，找到main如下\n\n<img title=\"\" src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230727130644.png\" alt=\"\" width=\"432\">\n\n很容易能发现sub140001120与sub140001140是关键函数，点进去发现如下\n\n<img title=\"\" src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230727130810.png\" alt=\"\" width=\"436\">\n\n发现256这个数字，结合crypt这个标题，容易想到rc4这个算法，然后这个算法是对称加密算法（参考ctf-wiki）也就是有加密前或者加密后的字符串和key都可以解出对应的明文/密文\n\n发现是rc4加密算法之后就简单了，根据上面main函数的最后部分，先得到加密的密文，然后找一个rc4解密脚本，就结束了，下面是我在ctf-wiki上找到的脚本，还挺好用的\n\n```python\nimport base64\ndef rc4_main(key = \"init_key\", message = \"init_message\"):\n    print(\"RC4解密主函数调用成功\")\n    s_box = rc4_init_sbox(key)\n    crypt = rc4_excrypt(message, s_box)\n    return crypt\ndef rc4_init_sbox(key):\n    s_box = list(range(256))\n    print(\"原来的 s 盒：%s\" % s_box)\n    j = 0\n    for i in range(256):\n        j = (j + s_box[i] + ord(key[i % len(key)])) % 256\n        s_box[i], s_box[j] = s_box[j], s_box[i]\n    print(\"混乱后的 s 盒：%s\"% s_box)\n    return s_box\ndef rc4_excrypt(plain, box):\n    print(\"调用解密程序成功。\")\n    plain = base64.b64decode(plain.encode('utf-8'))\n    plain = bytes.decode(plain)\n    res = []\n    i = j = 0\n    for s in plain:\n        i = (i + 1) % 256\n        j = (j + box[i]) % 256\n        box[i], box[j] = box[j], box[i]\n        t = (box[i] + box[j]) % 256\n        k = box[t]\n        res.append(chr(ord(s) ^ k))\n    print(\"res用于解密字符串，解密后是：%res\" %res)\n    cipher = \"\".join(res)\n    print(\"解密后的字符串是：%s\" %cipher)\n    print(\"解密后的输出(没经过任何编码):\")\n    return cipher\na=[188, 197, 18, 125, 133, 35, 132, 113, 123, 57, 40, 2, 211, 81, 243, 44, 137, 43, 166, 44, 175, 9] #cipher\nkey=\"12345678abcdefghijklmnopqrspxyz\"\ns=\"\"\nfor i in a:\n    s+=chr(i)\ns=str(base64.b64encode(s.encode('\nutf-8')), 'utf-8')\nrc4_main(key, s)\n```\n\n运行完就是flag：flag{nice_to_meet_you}\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230727140359.png)\n\n#### 小结\n\n这题主要的步骤应该是分析出是rc4加密算法，剩下的直接用脚本就行了\n\n## 三、happyctf\n\n这题做起来一点也不happy，刚下载附件的时候发现附带了一个pdb文件，对于从来没用过这个文件的我来说就直接战略性忽略了。但是后面才发现不带它直接分析是真滴折磨。完全不知道是干什么的。看了半天也不知道怎么做。最后加上了pdb，一下子就明朗了不少。至少知道了哪些函数是官方函数，是在干什么。\n\n下面是主要思路，点进main如下\n\n<img src=\"https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230727161408.png\" title=\"\" alt=\"\" width=\"676\">\n\n先是判断长度，需要长度为24才可以继续判断\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230727161505.png)\n\n这里很容易看明白，就是对输入逐字符进行操作，点进具体操作如下\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230727161555.png)\n\n就是将每个字符都与0x14异或一下，并push_back到v里面，也就是存入v，然后返回main\n\n![](C:\\Users\\打工人\\AppData\\Roaming\\marktext\\images\\2023-07-27-16-17-05-image.png)\n\n上面是关键部分，先将字符串存入key，然后也是逐字符进行操作，但是操作对象是v，也就是上面异或之后的字符，进行判断，而这里如果操作函数返回0则会错误，所以要返回1，点进操作函数\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230727161852.png)\n\n这里就是将key里面的字符与v9比较，不等则返回0，相等返回1. 而v9就是上面异或之后的字符\n\n**总结来说**，就是将我们的输入异或0x14之后，与key比较，不相等则错误。也就是将key逐字符异或0x14就得到了flag，脚本如下：\n\n```python\nx = list(\"rxusoCqxw{yqK`{KZqag{r`i\")\nflag = []\nfor i in range(0,24):\n    flag.append(chr(ord(x[i]) ^ 20))\nflag_ = ''.join(flag)\nprint(flag_)\n# flag如下 flag{Welcome_to_Neusoft}\n```\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230727162521.png)\n\n## 四、总结\n\n这上面三道题都对我来说有一定难度，但收获还是不小的。总结下来有下面几点：\n\n- gui类的题目，可以从中找到一些提示语句，然后直接去ida里面搜索对应语句，找到对应函数，直接进入核心判断逻辑语句\n\n- RC4的加解密题目，要关注256这个数字，如果有的话就要怀疑是不是RC4，是的话直接用已有的解密脚本做题\n\n- 如果附件带pdb一定要用，不然会很痛苦\n","tags":["ctf回顾"],"categories":["ctf"]},{"title":"攻防世界ctf - rev新手题","url":"/2023/07/20/1/","content":"\n> 最近实习中总有大把的时间闲着，我便趁着这段时间好好的做一做逆向的题目，希望可以提升一下自己吧。而且好像又重燃了对web的乐趣，所以我可能也会做一些web的题目。双修大法。\n\n## 一、Reversing-x64Elf-100\n\n很简单的逆向题，但这也算是好久以来第一个自己做出来的逆向题，需要好好记录一下。\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/2023-07-20-12-50-49-image.png)\n\n下载附件后就一个文件，先拖进exeinfop查一下壳和位数，然后直接拖进ida。\n\n按照以往的经验找到main函数，直接静态分析即可，发现主要判断逻辑在sub_4006FD中\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230720153104.png)\n\n进入之后发现如下\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230720153154.png)\n\n分析还是比较好分析的，但是这题主要时间花在了python代码的一些细节上，下面是解题脚本\n\n```python\ntag = list(\"Dufhbmf\")\ntag1 = list(\"pG`imos\")\ntag2 = list(\"ewUglpt\")\nflag = []\n\nfor i in range(0, 12):\n    if i % 3 == 0:\n        flag.append(chr(ord(tag[2 * (i // 3)]) - 1))\n    elif i % 3 == 1:\n        flag.append(chr(ord(tag1[2 * (i // 3)]) - 1))\n    elif i % 3 == 2:\n        flag.append(chr(ord(tag2[2 * (i // 3)]) - 1))\n\nresult_string = ''.join(flag)\nprint(result_string)\n```\n\n最后输出 如下，**Code_Talkers**即为本题flag\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230720154222.png)\n\n#### 小结\n\n主要是python代码上面，char型不能直接减一，需要先用ord()函数转成Ascii，而且强制转换在python里面是函数int（），需要括起来。而且字符串想改成字符数组需要用list()函数，往数组里面加需要用append()函数，而且字符数组想以字符串输出，需要用join函数。\n\n## 二、666\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230720154417.png)\n\n这题与上面题类似，只需静态分析即可，还是先拖进exeinfop，发现是64位，拖进ida，进行分析，先找到main函数，如下\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230720163707.png)\n\n别看上来给了一个flag，按照以往经验，肯定不对xs，大致思路如下:\n\n先是存储输入到v5，然后进入主要函数encode进行处理，处理结果以地址形式放到s中，接下来是先判断输入的长度是否正确，然后与enflag比较，一样即证明输入正确。\n\n> 其中strcmp是比较字符串的函数，为0则证明两个字符串相等，因此!strcmp基本都是判断两个字符串是否相等\n\n接下来是encode函数，最开始我以为是个官方函数，结果google了半天发现不是，然后点进去如下\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230720163726.png)\n\n很容易就可以看懂，下面是解题脚本\n\n```python\ntag = list(\"izwhroz\\\"\\\"w\\\"v.K\\\".Ni\")\nflag = []\ni = 0\nwhile i < 18:\n    flag.append(chr((ord(tag[i]) ^ 18) - 6))\n    flag.append(chr((ord(tag[i+1]) ^ 18) + 6))\n    flag.append(chr(ord(tag[i+2]) ^ 18 ^ 6))\n    i += 3\nflag_ = ''.join(flag)\nprint(flag_)\n```\n\n> 没想到^运算解方程的时候也可以直接移到等号另一侧，记下来\n\n最后结果如下，其中unctf{b66_6b6_66b}就是flag了\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230720164258.png)\n\n#### 小结\n\n下面主要是这个题中学到的一些新技巧\n\n查看key的值（之前对于这个问题总是一知半解），在ida中点进key，如下\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230720163533.png)\n\n然后点击dd，摁H即可变为10进制，摁Q变为16进制\n\n还有就是enflag的导出，刚点进去的时候如下，看见一堆双引号的我是一脸懵逼的\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230720163853.png)\n\n然后发现一个方法，就是点击enflag，直接ctrl+x，就会出现如下，就可以直接粘贴出来了，也发现了双引号其实也是字符串的一部分。他甚至还用\\给你转义好了可以直接用，很棒\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230720164007.png)\n\n## 三、easyRE1   |   lucknum\n\n这两题有点过于简单了，都是直接拖进ida，就发现flag了（确实easy）\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230721094726.png)\n\n但是我卡了好久最后甚至看的题解才做出来。中间我甚至以为这串字符串是什么编码，试了半天也没做出来。最后原因竟是需要用flag{}括起来。不明觉厉，前面的第一题我最开始用flag括起来不对，然后直接输入就对了。但这题还必须括起来。。\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230721094744.png)\n\nflag如图，即为flag{db2f62a36a018bce28e46d976e3f9864}\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230721095310.png)\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230721095348.png)\n\nflag如图 flag{c0ngr@tul@ti0n_f0r_luck_numb3r}\n\n## 四、reverse_re3 迷宫题\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230726102529.png)\n\n这题我分析了好久也没有思路，我最后做完总结一下，还是因为不会把迷宫从ida里面导出来或者直接看出来。最后无奈求助了题解，发现可以在ida里面直接看迷宫，又自己摸索了一下，最后做出来了。也算是对迷宫题有了一个初步的了解。\n\n这题的思路最开始我是一脸懵的，后来看了题解再看看才逐渐了解。你在玩一种很新的迷宫。（对我来说）\n\n首先进入main函数\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230726103904.png)\n\n发现进入了sub_940()函数，点进去\n\n![](C:\\Users\\打工人\\AppData\\Roaming\\marktext\\images\\2023-07-26-10-39-43-image.png)\n\n看到wasd的时候就知道是迷宫了，然后发现函数sub_86c每次循环都会用到，点进去，如下，这时已经知道202020里面就是迷宫数组了，但是不知道如何有效的表示出来，具体表示方法一会再说。\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230726104043.png)\n\n其中202AB0最开始为0，之后会自增，增到2便退出函数，如下\n\n而且结合上下两个图，发现迷宫应该是15*15的，而且有三个迷宫，由202AB0控制，只有当前面的输入循环完后v2仍为0才算通过了一个迷宫，需要通过三个迷宫才算成功。然后就可以返回上面看具体的wasd移动判断函数了。\n\n再看i j 在当前迷宫里面循环，当找到3的时候便停止，并且把i j分别存入行数和列数，便于之后判断。（后面看迷宫的时候也会发现每个迷宫只有一个3）\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230726104218.png)\n\n点进判断“d”的函数，如下\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230726104418.png)\n\n根据上面的分析，很容易看出202AB0为控制当前是哪个迷宫的，而且从前面得到的行列数开始判断，这个函数是判断d的，也就是右移，所以如果下一步是1则证明正确，就把下一步变成3，而所在的3变为1，这样就方便前面的函数下次找3的时候找到咱们移动后的位置开始判断，这样就实现了移动。并且如果下一步是4则返回1退出，也就是退出循环。即宏观来看：\n\n每个迷宫从3开始，途中必须每一步都要经过1，然后最终到达4证明当前迷宫通关。\n\n#### 小结\n\n然后下面是展示迷宫的操作：先点进去，迷宫最开始是下面这种情况，\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230726105353.png)\n\n**然后只需要右键-array如下**\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230726105641.png)\n\n然后如下设置，设置总数量，每行的数量，然后显示index，以及间距调为1，就\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/20230726105739.png)\n\n就会出现下面的样式\n\n![](https://blogkkk-1319553185.cos.ap-shanghai.myqcloud.com/img/2023-07-26-10-53-11-image.png)\n\n然后根据迷宫走，会走出下面的字符串，直接md5加密得到flag\n\nddsssddddsssdssdddddsssddddsssaassssdddsddssddwddssssssdddssssdddss\n\n即flag{aeea66fcac7fa80ed8f79f38ad5bb953}\n\n## 五、总结\n\n写完这篇文章我感觉我才算刚刚入门逆向。学会了编写一些简单的脚本解题，并且对一些ida的操作更加熟悉。也对迷宫题有了一些新的解题思路。\n\n希望之后能越来越好吧\n","tags":["ctf回顾"],"categories":["ctf"]},{"title":"nullcon HackIM CTF补题","url":"/2023/03/19/ctf/","content":"\n> 之前一直有各种事情没来得及补题，这周日终于闲了下来可以有时间补补题，这次的比赛虽然web就两道题但是很值得补一下的。而本菜鸟也只做出了最简单的第一题。害。现在正是Wolv ctf比赛的时候，看了看web题，嗯，好难。本菜鸟深知实力不够，干脆就趁这个时间把之前的题都补一补。\n\n# 一.cookie伪造\n\n这题应该是非常简单的一道题，下载源码后可以在代码中找到如下语句\n\n```python\n@app.route('/whoami')\ndef whoami():\n    role = request.cookies.get('role','guest')\n    really = request.cookies.get('really', 'no')\n    if role == 'admin':\n        if really == 'yes':\n            resp = 'Admin: ' + os.environ['FLAG']\n        else:\n            resp = 'Guest: Nope'\n    else:\n        resp = 'Guest: Nope'\n    return Response(resp, mimetype='text/plain')\n\nif __name__ == \"__main__\":\n    app.run(host='0.0.0.0', port='8080', debug=False)\n```\n\n可以很清晰的看到上面两个if语句都通过后就可以打印出flag，因此借助burp语句可以很快速的实现。如下图\n\n![](https://s3.bmp.ovh/imgs/2023/03/19/d67e3cc48487afd1.png)\n\n先是用burp抓包，然后构造一下cookie使其可以通过if，点击action将其发送到repeater，然后点击send便可以发送我们构造好了的cookie，之后便可以接收到flag了！如下\n\n![](https://s3.bmp.ovh/imgs/2023/03/19/febe47596ef06c7f.png)\n\n# 二、上传文件\n\n这题的题解主要参照[这个网址](https://www.cnblogs.com/xxpanda/p/17212918.html)\n\n但是很奇怪，我参照这个网址的方法下来出现了没有找到文件的标志\n\n![](https://s3.bmp.ovh/imgs/2023/03/19/5333aefb90522225.png)\n\n于是我又去找了另一个官方的[题解网址](https://ctftime.org/writeup/36347)，根据他的做法下来，也是一样的标志，这样只能说明flag文件已经被官方删除了？？具体原因我也不太清楚。但是方法肯定是这样的，如下\n\n```python\n@app.route('/', methods=['GET'])\ndef index():\n    output = io.StringIO()\n    output.write(\"Send me your zipfile as a POST request and I'll make them accessible to you ;-0.\")\n\n    return Response(output.getvalue(), mimetype='text/plain')\n\n\n@app.route('/', methods=['POST'])\ndef upload():\n    output = io.StringIO()\n    if 'file' not in request.files:\n        output.write(\"No file provided!\\n\")\n        return Response(output.getvalue(), mimetype='text/plain')\n\n    try:\n        file = request.files['file']\n\n        filename = hashlib.md5(secrets.token_hex(8).encode()).hexdigest()\n        dirname = hashlib.md5(filename.encode()).hexdigest()\n\n        dpath = os.path.join(\"/tmp/data\", dirname)\n        fpath = os.path.join(dpath, filename + \".zip\")\n\n        os.mkdir(dpath)\n        file.save(fpath)\n\n\n        with zipfile.ZipFile(fpath) as zipf:\n            files = zipf.infolist()\n            if len(files) > 5:\n                raise Exception(\"Too many files!\")\n\n            total_size = 0\n            for the_file in files:\n                if the_file.file_size > 50:\n                    raise Exception(\"File too big.\")\n\n                total_size += the_file.file_size\n\n            if total_size > 250:\n                raise Exception(\"Files too big in total\")\n\n        check_output(['unzip', '-q', fpath, '-d', dpath])\n\n\n        g = glob.glob(dpath + \"/*\")\n        for f in g:\n            output.write(\"Found a file: \" + f + \"\\n\")\n\n        output.write(\"Find your files at http://...:8088/\" + dirname + \"/\\n\")\n\n\n    except Exception as e:\n        output.write(\"Error :-/\\n\")\n\n    return Response(output.getvalue(), mimetype='text/plain')\n\n\n\nif __name__ == \"__main__\":\n    app.run(host='0.0.0.0', port='8080', debug=True)\n```\n\n先看代码，看见是让我们上传一个zip文件，当时就卡在了上传文件好像没什么用这里了，看了题解是要用软链接，不能直接上传，如下图：\n\n![](https://s3.bmp.ovh/imgs/2023/03/19/a55761c784ae3d80.png)\n\n先输入ln -s 将文件变为软链接格式，然后打包压缩，最后按照下面的代码上传文件\n\n```python\nimport requests\nurl = \"http://52.59.124.14:10015/\"\nfiles = {'file':open('test.zip','rb')}\nres = requests.post(url,files=files)\n\nprint(res.text)\n```\n\n最后回复如下\n\n![](https://s3.bmp.ovh/imgs/2023/03/19/c74d84a09b6ce064.png)\n\n然后在10016端口打开这个网址就会出现下面的网页\n\n![](https://s3.bmp.ovh/imgs/2023/03/19/89c09bd6962d99bd.png)\n\n正常来说应该是点击这个flag@就会出现flag，但是并没有出现，但是方法肯定就是这样的了。\n\n接下来就是有时间补补lactf的题，感觉那个题都还不错，值得补一下，剩下的就是等这个ctf结束看题解了。。。\n","tags":["ctf补题"],"categories":["ctf"]},{"title":"三种基础算法学习","url":"/2023/01/16/gui/","content":"\n# <center>一、归并排序</center>\n\n### 1、算法思想\n\n其实这些排序算法都是很基础的东西，要是有考试的话直接sort就够用，但是目的还是学习思想，有些题用这些算法里面的思想可能会有奇效。\n\n###### （一）归并排序思想：\n\n1. 先确定分界点，就是区间中点`mid = (l+r) / 2`\n\n2. 先两侧递归，即先递归左面排序，后递归右面排序\n\n3. 将上面两个排好序的序列合二为一，用到的是双指针算法\n\n###### （二）双指针算法\n\n简单来说就是两个指针分别指向两个有序数列（默认从小到大）的开头，比较两个指针指向的数字，这两个数中较小的数一定是两个序列的最小的数，填入新数组的开头，然后较小的数的指针加一，以此类推\n\n###### （三）稳定性\n\n归并排序是稳定的。稳定的含义简单来说就是在未排序之前两个数的相对位置和排序之后两个数的相对位置一致。就比如排序前a在b左边但是a=b，排序后a仍在b左边，不会在b右边，这就是稳定性。\n\n一般用于对某个对象的属性进行排序的时候，这个对象有多个属性时，比如价格，性价比两项，先对价格进行排序，排好之后再对性价比进行排序，但是要求对相同性价比的商品价格低的优先级仍高于价格高的优先级（即已有a=b，此时ab指代性价比，需要仍保持ab之前的排序不变，即价格的高低顺序一致），而不会反过来，这时候的排序算法就需要有稳定性的排序算法。而不稳定的排序算法（如快排）就会有可能使当a=b的时候ab的相对顺序和之前不一致。\n\n### 2、代码示例（模板来咯）\n\n```cpp\nint tmp[N];\nvoid merge_sort(int q[],int l, int r){\n    if(l >= r) return;\n    int mid = l+r >> 1;\n    merge_sort(q,l,mid);\n    merge_sort(q,mid+1,r);\n    int k = 0,i = l, j = mid+1;\n    while(i <= mid && j <= r)\n        if(q[i] < q[j]) tmp[k++] = q[i++];\n        else tmp[k++] = q[j++];\n    while(i <= mid) tmp[k++] = q[i++]\n    while(j <= r) tmp[k++] = q[j++];\n    for(i = l, j = 0; i <= r; i++,j++) q[i] = tmp[j];\n}\n```\n\n其实这种基础算法归根结底学的是思想，思想应该更加重要。\n\n# <center>二、快速排序</center>\n\n### 1、基本思想\n\n快速排序的基本思想十分简单，如下图，其中**调整位置并且递归**是主体部分，下面我将放出朴素快速排序和最近学到的一种很新的快速排序代码方式，**~~正所谓背模板嘛~~**。仅供参考。\n\n![](https://s3.bmp.ovh/imgs/2023/01/16/b0254238f986d7b8.jpg)\n\n（字丑请见谅）\n\n**注意** ：x位置也可以是随机的，不一定在中点或者左右端点。\n\n### 2、代码如下：\n\n###### （一）朴素快速排序算法：\n\n本来想敲一遍的，但是发现朴素算法不够优雅肯定用不到，所以就讲一下基本思路就好了\n\n1. 建立两个数组a[N]与b[N]；\n\n2. 对q[x]进行扫描，大于等于x的放到a里面，小于x的放到b里面\n\n3. 最后把a里面的数放到q前面，然后紧接着把b里面的数放到q里面完成。\n\n4. 然后分别对左右两边递归。结束\n\n这种算法的时间复杂度不大，仍是O(n)（指一次递归过程中，不是总的时间复杂度），但是用到了额外的空间，空间复杂度较高。下面这种“优雅”的方法可以有效避免这一点。\n\n###### （二）优雅的快排算法\n\n基本思路，用到两个指针i，j；\n\n1. i 指针负责判断指向的数是否小于x，如果符合条件，则自增，如果指向的数 \\leq x，停止移动\n\n2. j 指针负责判断指向的数是否小于x，如果符合条件，则自增，如果指向的数 \\geq x，停止移动\n\n3. 如果i指针和j指针同时停止移动，则交换两指针指向的内容，保证了i指针所指向的数之前全部小于x，j指针指向的数之后均大于x；\n\n4. 当i指针\\geq j指针后，停止循环\n\n5. 然后以l到j，j+1到r为分界分别递归\n\n代码如下\n\n```cpp\nvoid quick_sort(int q[],int l,int r){\n    if(l >= r) return;\n    int i = l-1, j = r+1;\n    int x = q[(l+r)/2];\n    while(i < j){\n       do i++; while(q[i] < x);\n       do j--; while(q[j] > x);\n       if(i < j) swap(q[i],q[j]);\n    }\n    quick_sort(q,l,j);\n    quick_sort(q,j+1,r);\n}\n```\n\n这种方法就有效避免了额外再开辟空间的情况，空间复杂度较好。\n\n# <center>三、二分法</center>\n\n### 1、算法思路\n\n二分查找主要分为两类，一类是整数二分查找，一类是实数二分查找。整数二分查找比较困难，因为边界问题很多，需要考虑的事情很多，下面说一下二分查找的基本思路。\n\n**注：有单调性的一定可以用二分，没有单调性的不一定不能用二分，二分的本质并不是单调性，关系并不是很大**\n\n![](https://s3.bmp.ovh/imgs/2023/01/20/92a8b513b04c4e3b.png)\n\n如上图，整数二分的本质并不在单调性，只不过大部分例子都是单调性有关而已。而实际的本质是把一个区间按**某个性质分为两段**，**（由于是整数二分则上面两段的箭头指向的端点并不重合）**，通过二分就可以分别找出两个箭头所指向的位置。而正由于有两个区间的端点，因此有两个模板分别求这两个箭头指向的位置。简单来说：\n\n- 左侧箭头指向的是符合红色条件的最右侧的位置\n\n- 右侧箭头指向的是符合绿色条件的最左侧的位置\n\n为方便理解，可以以一道经典例题为例：\n\n> 给定一个按照升序排列的长度为 n的整数数组，返回一个元素 k的起始位置和终止位置（位置从 0开始计数）如果数组中不存在该元素，则返回 -1 -1。\n\n即如果序列为1,2,3,3,3,4,5,5，需要返回3的起始位置和终止位置，则用二分较快。其中起始位置的3就代表上图右侧箭头，指向的是符合绿色条件的最左侧的位置，即此处的3把整个区间按性质：是否大于等于3分成两半。左侧均小于三，右侧均大于等于3；终止位置3就代表上图左侧箭头，指向的是符合红色条件的最右侧位置，即此处的3把整个区间按性质：是否小于等于3分成两半。左侧均小于等于三，右侧均大于3\n\n因此，像这种找区间左右端点的题就需要分别使用两种模板，如下：\n\n### 2、代码模板\n\n###### (一)、整数模板\n\n```cpp\n// 模板一\nwhile(l < r){\n    int mid = l + r >> 1;\n    if(check(mid)) r = mid;\n    else l = mid + 1;\n}\n//模板二 if后面跟l就加一\nwhile(l < r){\n    int mid = l+ r + 1 >> 1;   // +1是为了防止死循环\n    if(check(mid)) l = mid;\n    else r = mid - 1;\n}\n```\n\n**注意：L = mid 时，初始化mid的时候需要+1，是为了防止死循环**\n","tags":["算法基础"],"categories":["算法学习"]},{"title":"第0篇文章","url":"/2023/01/14/hello-world/","content":"\n# 欢迎来到我的博客！\n\n俗话说授人以鱼不如授人以渔，本博客主要基于这位大佬的[博客文章](http://blog.haoji.me/build-blog-website-by-hexo-github.html)（网址好像寄了）为教程进行建设的。后续讨论区功能也将加入，希望到时候可以一起来玩♂耍与交流。\n\n（2023.1.16更新）本博客由于之前一段时间比较忙处于完全废弃的状态，如今从新拾起博客，并且换了一个更加美观的主题。今后的博客应该会主要记录一下学习ctf过程中的知识点总结和一些算法的学习总结。（2023.7.12更新）博客再次重整，删去了很多没必要的文章，内容再次精简，希望这是一个新的开始。\n此博客的所有源码均可以在我的[github仓库](https://github.com/thenights1/thenights1.github.io)中找到，各位大佬也可以去github和我一起交流。\n\n如有错误欢迎各位大佬前来指正。\n","tags":["引言"]},{"title":"Markdown基础语法总结","url":"/2022/09/29/Markdown/","content":"\n# 占楼，未来的Markdown的一些语法学习我将会在这里实时更新，如果内容过多我会另设文章\n\n## 就当是一个监督学习的文章占楼！\n\nMarkdown是一种轻量级标记语言，排版语法简洁，让人们更多地关注内容本身而非排版。它使用易读易写的纯文本格式编写文档，可与HTML混编，可导出 HTML、PDF 以及本身的 .md 格式的文件。因简洁、高效、易读、易写，Markdown被大量使用，如Github、Wikipedia、简书等。（搜索引擎得来）   \nMarkdown的语法十分简单，常用的标记符号不超过十个，用于日常写作记录绰绰有余，不到半小时就能完全掌握。\n\n### 1.[标题语法](#1)\n\n### 2.[插入代码语法](#2)\n\n### 3.[跳转目录语法](#3)\n\n### 4.[插入图片语法](#4)\n\n### 5.[删除线问题](#5)\n\n<p id=\"1\"></p>\n\n## 1.Markdown标题语法\n\n要创建标题，在单词或短语前面添加井号 (#):由一到六，#越多标题文字显示越小\n\n如下所示\n\n```\n# head1\n## head2\n### head3\n#### head4\n##### head5\n###### head6\n```\n\n效果如下（注意#后面要加空格）\n\n# head1\n\n## head2\n\n### head3\n\n#### head4\n\n##### head5\n\n###### head6\n\n<p id=\"2\"></p>\n\n## 2.Markdown代码语法\n\n（突然想到也没必要按顺序写笔记，应该是学了什么写什么，嘿嘿，好久没更新了，来浅浅更新一下）\n\nMarkdown支持直接用行缩进四个空格或者一个制表符来创建一个代码块,但是这种要注意代码块要和上一段留出一行来，不然就会无法显示代码块\n\n    int i=;\n    int j=0;\n\n就像上面这种，但是这样我感觉，很不方便，所以我更倾向于下面这种，在代码块的上下分别用用三个~或者三个```将其包起来，这样还能显示代码行数，我更倾向于这种\n\n```\n~~~\nint i=0;\nint j=0;\n~~~\n```\n\n<p id=\"3\"></p>\n\n## 3.Markdown跳转目录语法\n\n这个我测试了半天，简单如下\n\n```\n[标题名](#标题链接)\n```\n\n正常来说标题链接就是小标题的名字，但是我发现我用了之后只能在vscode编写的时候可以跳转，而在网页中无效，我也不知道什么原因，搜索之后也不知道，所以我才用了另一种方法，就是在标题的上方加上这句\n\n```\n[相应标题](#锚点)\n\n<p id= \"锚点\"></p>  //这里的锚点最好用数字1234，很好用\n```\n\n这样就可以跳转啦\n\n<p id=\"4\"></p>\n\n## 4.Markdown插入图片语法\n\n图片相关的代码很简单，常用的就两种（准确的说是我常用），第一种就是简单地插入图片或gif，代码如下\n\n```\n![简单描述，不会显示](图片地址 \"图片描述，当鼠标悬停会显示\")\n\n示例代码：\n\n![简单描述，不会显示](https://upload-bbs.mihoyo.com/format,gif \"图片描述，当鼠标悬停会显示\")\n```\n\n示例如下\n![图片](https://upload-bbs.mihoyo.com/upload/2022/10/04/286746010/cfec48f4dc28a69315f9986dae9d5561_7495227528267660980.gif?x-oss-process=image/auto-orient,0/interlace,1/format,gif \"可爱的小东西\" )\n\n而如果想插入链接，就是点击图片跳转，需要再用一个方括号将原有Markdown图片语法括起来，然后在旁边加上需要链接的网址，如下代码\n\n```\n[![简单描述，不会显示](图片地址 \"图片描述，当鼠标悬停会显示\")](网址)\n```\n\n如下图\n\n[![图片](https://upload-bbs.mihoyo.com/upload/2022/09/27/33087162/56c1464ae633055b7bb74bb3f924328a_3330391065587151535.png# \"好美\")](https://www.bh3.com/)\n\n但是这样图片就太大了，经过一顿百度，发现这东西还和具体的Markdown编辑器有关，不同的编辑器有不同的方式，但是我用的这种好像都不太可以，所以只能回归HTML了，HTML这样表示，可以调整大小，如下：\n\n```\n<img src=\"https://upload-bbs.mihoyo.com/upload/2022/09/27/33087162/56c1464ae633055b7bb74bb3f924328a_3330391065587151535.png\"  width=\"50%\" height=\"50%\" >   //也就是\n<img src=\"图片地址\" width=\" %\" hegiht=\" %\">\n```\n\n[<img src=\"https://upload-bbs.mihoyo.com/upload/2022/09/27/33087162/56c1464ae633055b7bb74bb3f924328a_3330391065587151535.png\" alt=\"好美\" width=\"50%\" height=\"50%\" >](https://www.bh3.com/)\n\n<p id=\"5\"></p>\n\n## 5.删除线问题\n\n今天在写总结的时候发现，删除线并不只是两个~就行，一个也行！？\n代码如下\n\n```\n~我是删除的~\n~ 我是删除的 ~\n~~我是删除的~~\n~~ 我是删除的 ~~\n~ ~ 我是删除的 ~ ~\n```\n\n而效果如下，立竿见影\n\n~我是删除的~\n~ 我是删除的 ~\n~~我是删除的~~\n~~ 我是删除的 ~~\n~ ~ 我是删除的 ~ ~\n\n总结：一个~也能用，但是**必须要贴合文字**，一旦有空格就无法显示删除线，两个 ~也是这样（看我这里打了个空格，不打的话就会和前面那个 ~遥相呼应，就会显示删除线，血泪的教训）","tags":["Markdown"]}]